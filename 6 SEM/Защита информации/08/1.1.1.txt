> with(numtheory);             # Подключение пакета для работы с теорией чисел (факторизация, функции Эйлера и т.д.)
> with(StringTools);           # Подключение пакета для работы со строками (конкатенация, длина, подстроки)

> E := 1925928379;             # Открытая экспонента E для RSA
> m := 3273550829;             # Модуль m (n) для RSA

> al := table(                 # Таблица соответствия двухзначных кодов символам (русский алфавит, пробел и «€»)
>     ["01" = "а", "02" = "б", "03" = "в", "04" = "г", "05" = "д", "06" = "е",
>      "07" = "ж", "08" = "з", "09" = "и", "10" = "й", "11" = "к", "12" = "л",
>      "13" = "м", "14" = "н", "15" = "о", "16" = "п", "17" = "р", "18" = "с",
>      "19" = "т", "20" = "у", "21" = "ф", "22" = "х", "23" = "ц", "24" = "ч",
>      "25" = "ш", "26" = "щ", "27" = "ъ", "28" = "ы", "29" = "ь", "30" = "э",
>      "31" = "ю", "32" = "€", "00" = " "]                               
> );

> res := "";                   # Инициализация пустой строки для накопления расшифрованного текста

> s := ifactors(m);            # Факторизация m на простые множители
> p1 := s[2][1][1];            # Получение первого простого множителя p1
> p2 := s[2][2][1];            # Получение второго простого множителя p2

> mc := p1 * p2;               # Проверка: p1 * p2 должно равняться исходному m
> if mc = m then
>     "¬злом получилс€.";      # Если проверка пройдена, выводим confirmation
> end if;

> phM := (p1 - 1) * (p2 - 1);  # Вычисление φ(n) = (p1−1)(p2−1)

> D1 := (E &^ (phi(phM) - 1)) mod phM;
                               # Нахождение закрытой экспоненты d ≡ E^(−1) mod φ(n)
                               # Используется факт: E^(φ(φ(n))−1) ≡ E^(−1) mod φ(n)

> mes := [                      # Список зашифрованных числовых блоков
>     1169117912, 1244629799, 2168855069, 1243855092, 437023454,
>     2762017513, 127848283, 47229456, 2567946795, 2860789969,
>     3245731988, 34676752, 1557331563, 1308187811
> ];

> lenm := nops(mes);           # Определение количества блоков в списке mes

> for i to lenm do             # Итерация по каждому блоку
>     des := (mes[i] &^ D1) mod m;      # Расшифровка блока: возведение в степень d по модулю m
>     str_mes := convert(des, string);  # Преобразование числа в строку

>     while length(str_mes) < 10 do     # Добавление ведущих нулей до длины 10 символов
>         str_mes := cat("0", str_mes);
>     end do;

>     stop_point := length(str_mes) - 1; # Определение границы для поблочной нарезки по 2 знака

>     for j by 2 to stop_point do       # Проход по строке с шагом 2
>         sample := SubString(str_mes, j .. j + 1);  # Извлечение двухсимвольного кода
>         res := cat(res, al[sample]);               # Добавление соответствующего символа в результат
>     end do;
> end do;

> res;                          # Вывод окончательного расшифрованного текста
> NULL;                         # Завершение без ошибки
