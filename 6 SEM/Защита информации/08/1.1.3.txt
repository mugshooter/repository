> with(numtheory);             # Подключаем пакет для работы с теорией чисел (factor, phi и др.)
> with(StringTools);           # Подключаем пакет для работы со строками (concat, length, SubString)

> E := 1054875165;             # Открытая экспонента E (обычно нечётное 32-битное число)
> m := 3571723717;             # Модуль m = p1 * p2

> s := ifactors(m);            # Факторизуем m → [1, [[p1,1], [p2,1]]]
> p1 := s[2][1][1];            # Извлекаем первый простой множитель p1
> p2 := s[2][2][1];            # Извлекаем второй простой множитель p2

> mc := p1 * p2;               # Проверка: произведение p1·p2 должно давать исходное m
> if mc = m then               # Если произведение совпадает, то факторизация верна
>     "¬злом получилс€.";      #   Выводим сообщение о «взломе» модуля
> end if;

> phM := (p1 - 1) * (p2 - 1);  # Вычисляем φ(m) = (p1−1)(p2−1)

> D1 := (E &^ (phi(phM) - 1)) mod phM;
                               # Находим закрытую экспоненту d ≡ E^(−1) mod φ(m)
                               # Используется приём: E^(φ(φ(m))−1) ≡ E^(−1) mod φ(m)

> mes := [                      # Список зашифрованных числовых блоков
>     3371389761, 3108772900, 2789090756, 1702524865,
>     1459737350, 3094823069, 2426005999, 3088333655,
>     1346615411, 2119806179, 1572525825, 1397236295,
>     490884957, 1694795075
> ];

> lenm := nops(mes);           # Определяем количество блоков в массиве mes

> al := table([                # Таблица кодов → символы (русский алфавит, пробел и «€”)
>     "01" = "а", "02" = "б", "03" = "в", "04" = "г", "05" = "д",
>     "06" = "е", "07" = "ж", "08" = "з", "09" = "и", "10" = "й",
>     "11" = "к", "12" = "л", "13" = "м", "14" = "н", "15" = "о",
>     "16" = "п", "17" = "р", "18" = "с", "19" = "т", "20" = "у",
>     "21" = "ф", "22" = "х", "23" = "ц", "24" = "ч", "25" = "ш",
>     "26" = "щ", "27" = "ъ", "28" = "ы", "29" = "ь", "30" = "э",
>     "31" = "ю", "32" = "€", "00" = " " 
> ]);

> res := "";                   # Инициализируем пустую строку для собираемого расшифрованного текста

> for i to lenm do             # Для каждого зашифрованного блока mes[i]:
>     des := (mes[i] &^ D1) mod m;      # 1) Расшифровка: возводим блок в степень d по модулю m
>     str_mes := convert(des, string);  # 2) Переводим результат в строку для дальнейшей нарезки

>     while length(str_mes) < 10 do     # 3) Добавляем ведущие нули до фиксированной длины в 10 символов
>         str_mes := cat("0", str_mes);
>     end do;

>     stop_point := length(str_mes) - 1; # Определяем конечную позицию для извлечения двухцифровых кодов

>     for j by 2 to stop_point do       # 4) Идём по строке парами символов
>         sample := SubString(str_mes, j .. j + 1);  #    Извлекаем двузначный код
>         res := cat(res, al[sample]);               #    Добавляем соответствующий символ из таблицы al
>     end do;
> end do;

> res;                          # Выводим собранную расшифровку текста
> NULL;                         # Завершаем выполнение без ошибок
