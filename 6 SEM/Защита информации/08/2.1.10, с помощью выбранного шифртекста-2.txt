> with(numtheory);               # Подключаем пакет для работы с теорией чисел
> with(RandomTools);             # Подключаем пакет для генерации случайных чисел

> q1 := nextprime(Generate(integer(range = 3 .. 10^10)));  
                                 # Генерируем случайное целое и берём следующее простое → q1
> q2 := nextprime(Generate(integer(range = 3 .. 10^10)));  
                                 # Аналогично генерируем второе простое → q2

> print("n = ");                 # Выводим метку для модуля n
> n := q1 * q2;                  # Вычисляем модуль n = q1·q2

> e := Generate(integer(range = 3 .. 10^5));  
                                 # Генерируем случайное целое для экспоненты e
> while igcd(e, phi(n)) <> 1 do  # Проверяем, что gcd(e, φ(n)) = 1
>     e := Generate(integer(range = 3 .. 10^5));  
                                 # Если нет, генерируем новое e
> end do;

> print("e = ", e);              # Выводим найденное значение e

> igcd(e, phi(n));               # Проверка: gcd(e, φ(n))

> d1 := (e &^ (phi(phi(n)) - 1)) mod phi(n);  
                                 # Вычисляем закрытую экспоненту d1 ≡ e⁻¹ mod φ(n)

> print("N = ");                 # Выводим метку для исходного сообщения N
> N := 12345;                    # Задаём демонстрационное значение N
> N_d := (N &^ d1) mod n;        # Вычисляем N_d = N^d1 mod n

> x := Generate(integer(range = 3 .. 10^5));  
                                 # Генерируем случайный x
> y := (x &^ e) mod n;           # Шифруем x: y = x^e mod n

> M := y * N;                    # Формируем комбинированное значение M = y·N
> z := (M &^ d1) mod n;          # Расшифровываем M: z = M^d1 mod n

> N1 := (1/x mod n) * z mod n;   # Восстанавливаем исходное N1 = x⁻¹·z mod n

> N1 - N_d;                      # Проверка: N1 должно совпасть с N_d

> NULL;                          # Завершаем выполнение
