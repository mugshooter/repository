> with(numtheory);               # подключаем пакет с теорией чисел
> with(RandomTools);             # подключаем пакет для генерации случайных данных

> p := nextprime(Generate(integer(range = 3 .. 10^15)));  # генерируем большое случайное простое p
> q := nextprime(Generate(integer(range = 3 .. 10^15)));  # генерируем большое случайное простое q

> n := p * q;                    # вычисляем модуль n = p·q
> phn := (p - 1) * (q - 1);      # вычисляем φ(n) = (p−1)(q−1)

> e := nextprime(Generate(integer(range = 3 .. 10^15)));  # генерируем кандидата для открытой экспоненты e
> while igcd(e, phn) <> 1 do     # пока gcd(e, φ(n)) ≠ 1
>     e := nextprime(Generate(integer(range = 3 .. 10^15)));  # генерируем новое e
> end do;                        # заканчиваем, когда e взаимно просто с φ(n)

> e;                             # выводим найденное e

> d := 'd';                      # объявляем символическую переменную для закрытой экспоненты
> s := msolve(d*e = 1, phn);     # решаем d·e ≡ 1 mod φ(n)
> assign(s);                     # присваиваем найденное значение d

> d;                             # выводим рассчитанное d

> m1 := Generate(integer(range = 3 .. 10^10)) mod n;  # генерируем случайное сообщение m1
> m2 := Generate(integer(range = 3 .. 10^10)) mod n;  # генерируем случайное сообщение m2
> m3 := m1 * m2 mod n;           # вычисляем m3 = m1·m2 mod n

> m1s := (m1 &^ d) mod n;        # «подписываем» m1 (шифруем d)
> m2s := (m2 &^ d) mod n;        # «подписываем» m2
> m3s := m1s * m2s mod n;        # мультипликативность подписи: σ(m1)·σ(m2)

> m := (m3 &^ d) mod n;          # «подписываем» m3 напрямую
> m3s - m;                       # проверяем, что σ(m1)·σ(m2) = σ(m1·m2)

> NULL;
