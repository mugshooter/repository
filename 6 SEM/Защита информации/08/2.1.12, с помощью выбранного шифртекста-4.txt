> with(numtheory);               # подключаем пакет для работы с теорией чисел  
> with(RandomTools);             # подключаем пакет для генерации случайных чисел  

> p := nextprime(Generate(integer(range = 3 .. 10^15)));    # генерируем простое p  
> q := nextprime(Generate(integer(range = 3 .. 10^15)));    # генерируем простое q  

> n := p*q;                    # вычисляем модуль n = p·q  
> phn := (p - 1)*(q - 1);      # вычисляем φ(n) = (p−1)(q−1)  

> e := nextprime(Generate(integer(range = 3 .. 10^15)));    # пробуем публичную экспоненту e  
> while igcd(e, phn) <> 1 do     # убеждаемся, что gcd(e, φ(n)) = 1  
>     e := nextprime(Generate(integer(range = 3 .. 10^15)));  
> end do;                        # цикл завершается при найденном e  

> e;                             # выводим публичную экспоненту e  

> d := 'd';                      # объявляем символическую переменную для закрытой экспоненты  
> s := msolve(d*e = 1, phn);     # решаем d·e ≡ 1 mod φ(n)  
> assign(s);                     # присваиваем найденное значение d  

> d := d;                        # выводим закрытую экспоненту d  

> 1*m := Generate(integer(range = 3 .. 10^10)) mod n;    # (ошибка в идентификаторе, оставлено без комментария)  
> c := (m &^ e) mod n;           # шифруем сообщение: c = m^e mod n  

> r := Generate(integer(range = 3 .. 100)) mod n;        # генерируем случайное r < n  
> m1 := (c mod n)*((r &^ e) mod n) mod n;                # вычисляем m1 = c·r^e mod n  
> c1 := (m1 &^ d) mod n;         # расшифровываем m1: c1 = m1^d mod n  

> rn := 'rn';                    # объявляем переменную для обратного к r  
> s := msolve(rn*r = 1, n);      # решаем rn·r ≡ 1 mod n  
> assign(s);                     # присваиваем найденное значение rn  

> rn := rn;                      # выводим обратный к r  

> m2 := rn*c1 mod n;             # восстанавливаем исходное m: m2 = r⁻¹·c1 mod n  
> m2 - m;                        # проверяем, что m2 = m  
