> with(numtheory);             # Подключаем пакет для работы с теорией чисел (phi, ifactors и т.д.)
> with(RandomTools);           # Подключаем пакет для генерации случайных чисел

> Digits := 40;                # Устанавливаем точность вычислений (количество значущих цифр) для операций с большими числами

> p := nextprime(Generate(integer(range = 3 .. 10^20)));  
                               # Случайно генерируем целое в диапазоне [3, 10^20] и берём следующее простое → p
> q := nextprime(nextprime(p));  
                               # Берём следующее простое после p, а затем ещё одно → q

> if q < p then                # Если порядок пар (p, q) нарушен, меняем их местами
>     t := p;
>     p := q;
>     q := t;
> end if;

> N := p * q;                  # Вычисляем модуль N = p·q

> k := 1 + floor(sqrt(N));     # Начальное приближение: k = ⌊√N⌋ + 1
> y := k^2 - N;                # Вычисляем разность y = k² − N
> d := 1;                      # Инициализируем приращение для y
> halfN := N / 2;              # Половина N, используется для ограничения цикла

> while floor(sqrt(y)) <> sqrt(y) do  # Пока y не является точным квадратом
>     y := y + 2*k + d;        # Обновляем y по формуле: y_new = y_old + 2k + d
>     d := d + 2;              # Увеличиваем приращение d на 2
>     if halfN <= floor(sqrt(y)) then  # Если корень y превысил N/2, считая факторизацию бесперспективной
>         print("ћножители не найдены");  # Выводим сообщение об ошибке
>         break;                # Выходим из цикла
>     end if;
> end do;

> x := sqrt(N + y);            # Вычисляем x = √(N + y)
> y := sqrt(y);                # Теперь y становится √y, т.е. вторым корнем

> p1 := x - y;                 # Первый фактор: x − y
> q1 := x + y;                 # Второй фактор: x + y

> p1 - p;                      # Проверка: p1 − исходное p должно быть 0
> q1 - q;                      # Проверка: q1 − исходное q должно быть 0

> NULL;                        # Завершаем выполнение без ошибок
