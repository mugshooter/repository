> with(numtheory);               # Подключаем пакет numtheory для работы с теорией чисел (phi, ifactors и пр.)
> with(RandomTools);             # Подключаем пакет RandomTools для генерации случайных чисел

> p := nextprime(Generate(integer(range = 3 .. 10^5)));   # Генерируем случайное целое в [3..10^5] и берём следующее простое → p
> q := nextprime(Generate(integer(range = 3 .. 10^5)));   # Аналогично генерируем второе простое → q

> n := p * q;                    # Вычисляем модуль n = p·q
> phN := (p - 1) * (q - 1);      # Вычисляем функцию Эйлера φ(n)

> eA := nextprime(Generate(integer(range = 3 .. 10^5))); # Первичная попытка выбрать экспоненту eA (простое число)
> while igcd(eA, phN) <> 1 do    # Проверяем, что gcd(eA, φ(n)) = 1
>     eA := nextprime(Generate(integer(range = 3 .. 10^5))); # Если нет — пробуем снова
> end do;                        # Завершаем цикл, когда условие выполнено

> eA;                            # Вывод конечного значения eA

> eB := nextprime(Generate(integer(range = 3 .. 10^5))); # Аналогичная генерация второй экспоненты eB
> while igcd(eB, phN) <> 1 do
>     eB := nextprime(Generate(integer(range = 3 .. 10^5)));
> end do;                        # Убеждаемся, что gcd(eB, φ(n)) = 1

> eB;                            # Вывод конечного значения eB

> m := Generate(integer(range = 3 .. 10^5)) mod n;  # Генерируем случайное сообщение m < n

> c1 := (m &^ eB) mod n;         # Шифруем m экспонентой eB → c1
> c2 := (m &^ eA) mod n;         # Шифруем m экспонентой eA → c2

> x := 'x';                      # Объявляем символическую переменную x
> y := 'y';                      # Объявляем символическую переменную y
> _Z1 := 1;                      # Инициализируем служебную переменную _Z1 (требуется isolve)

> s := isolve(eA*y + eB*x = 1); # Решаем диофантово eA·y + eB·x = 1 (находим коэффициенты x,y)
> assign(s);                     # Присваиваем найденные значения x и y

> x;                             # Вывод текущего значения x (коэффициент при eB)
> y;                             # Вывод текущего значения y (коэффициент при eA)

> if y < 0 then                  # Если y отрицательно, готовим положительные степени для дешифрования
>     p := x;                    # Временное хранение x в p для обмена
>     x := y;                    # Переносим y в x
>     y := p;                    # Восстанавливаем x из p в y
>     p := c1;                   # Временное хранение c1 в p для обмена
>     c1 := c2;                  # Меняем местами c1 и c2
>     c2 := p;                   # Восстанавливаем c1 из p в c2
> end if;                        # Конец условного блока

> d1 := (c1 &^ abs(x)) mod n;    # Вычисляем частичный декод d1 = c1^|x| mod n

> dn1 := 'dn1';                  # Объявляем символическую переменную dn1
> t := msolve(d1*dn1 = 1, n);    # Находим обратный элемент dn1: d1·dn1 ≡ 1 mod n
> assign(t);                     # Присваиваем найденное значение dn1

> dn1;                           # Вывод значения dn1
> d1*dn1 mod n;                  # Проверка: d1*dn1 mod n должно быть 1

> d2 := (c2 &^ y) mod n;         # Вычисляем второй частичный декод d2 = c2^y mod n

> m1 := dn1 * d2 mod n;          # Восстанавливаем исходное сообщение m1 = dn1·d2 mod n
> m1 - m;                        # Проверка: m1 − m должно быть 0

> NULL;                          # Завершаем выполнение без ошибок
