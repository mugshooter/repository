> with(numtheory);                                       # Подключаем пакет для работы с теорией чисел (phi, ifactors и т.д.)
> with(RandomTools);                                     # Подключаем пакет для генерации случайных чисел

> e := 3;                                                # Устанавливаем малое публичное экспонентное значение e = 3

> p1 := nextprime(Generate(integer(range = 4 .. 10^5))); # Генерируем случайное целое в [4..10^5] и берём следующее простое → p1
> q1 := nextprime(Generate(integer(range = 4 .. 10^5))); # Аналогично генерируем второе простое → q1
> n1 := p1 * q1;                                         # Вычисляем первый модуль n1 = p1·q1

> p2 := nextprime(Generate(integer(range = 4 .. 10^5))); # Генерируем новый кандидат для второго простого p2
> while p2 = p1 or p2 = q1 do                            # Проверяем, что p2 не совпадает ни с p1, ни с q1
>     p2 := nextprime(Generate(integer(range = 4 .. 10^5)));
> end do;
> p2;                                                    # Выводим сгенерированное значение p2

> q2 := nextprime(Generate(integer(range = 4 .. 10^5))); # Генерируем q2 и проверяем на уникальность
> while q2 = p1 or q2 = q1 do
>     q2 := nextprime(Generate(integer(range = 4 .. 10^5)));
> end do;
> q2;                                                    # Выводим сгенерированное значение q2
> n2 := p2 * q2;                                         # Вычисляем второй модуль n2 = p2·q2

> p3 := nextprime(Generate(integer(range = 4 .. 10^5))); # Генерируем третий простой p3, уникальный среди предыдущих
> while p3 = p1 or p3 = q1 or p3 = p2 or p3 = q2 do
>     p3 := nextprime(Generate(integer(range = 4 .. 10^5)));
> end do;
> p3;                                                    # Выводим сгенерированное значение p3

> q3 := nextprime(Generate(integer(range = 4 .. 10^5))); # Генерируем третий простой q3, уникальный среди предыдущих
> while q3 = p1 or q3 = q1 or q3 = p2 or q3 = q2 do
>     q3 := nextprime(Generate(integer(range = 4 .. 10^5)));
> end do;
> q3;                                                    # Выводим сгенерированное значение q3
> n3 := p3 * q3;                                         # Вычисляем третий модуль n3 = p3·q3

> igcd(n1, n2);                                          # Проверка: gcd(n1,n2)=1 (модули попарно взаимно просты)
> igcd(n1, n3);                                          # Проверка: gcd(n1,n3)=1
> igcd(n2, n3);                                          # Проверка: gcd(n2,n3)=1

> igcd(n1, e);                                           # Проверка: gcd(n1,e)=1 (экспонента корректна)
> igcd(n2, e);                                           # Проверка: gcd(n2,e)=1
> igcd(n3, e);                                           # Проверка: gcd(n3,e)=1

> m := ((Generate(integer(range = 3 .. 10^10)) mod n1)      # Генерируем случайное сообщение m
>      mod n2) mod n3;                                       # и приводим его к диапазону меньше минимального модуля
> 
> y1 := (m &^ e) mod n1;                                  # Шифруем m на модуле n1: y1 = m^e mod n1
> y2 := (m &^ e) mod n2;                                  # Шифруем m на модуле n2: y2 = m^e mod n2
> y3 := (m &^ e) mod n3;                                  # Шифруем m на модуле n3: y3 = m^e mod n3

> pm := chrem([y1, y2, y3], [n1, n2, n3]);                # Объединяем шифротексты по КТТ → pm ≡ m^e mod N (N=n1·n2·n3)
> m1 := root(pm, 3);                                      # Извлекаем целый кубический корень: m1 = √[3]{pm}
> m1 - m;                                                 # Проверяем, что восстановленное m1 совпадает с исходным m

> NULL;                                                   # Завершаем выполнение без ошибок
