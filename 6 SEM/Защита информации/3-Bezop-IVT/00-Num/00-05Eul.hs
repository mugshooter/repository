   -- Демонстрация рекурсивного вычисления значения
   -- функции Эйлера без использования функционалов
   -- (н е э ф ф е к т и в н а я  реализация).
   -- Использована следующая функция на языке C:
   -- 
   -- long Euler(long n,long k)
   -- {
   --   if (n==1)
   --     return 1;
   --   else if (k==n)
   --          return 0;
   --        else if (GCD(k,n)==1)
   --               return 1 + Euler(n,k+1);
   --             else return Euler(n,k+1);
   -- }
   --
   -- Автор "переписывания": Швецкий М.В. 
   --                        (17.12.2019, 19:33-19:39)
   ---------------------------------------------------
   euler n = abc_euler n 1
      where abc_euler n k 
                 | n==1        = 1
                 | k==n        = 0
                 | gcd k n ==1 = 1 + abc_euler n (k+1)
                 | True        =     abc_euler n (k+1)

   -- ***********************************************
   -- Демонстрация вычисления значения функции Эйлера
   -- с использованием функционалов
   -- (н е э ф ф е к т и в н а я  реализация).
   --   
   -- Автор: Швецкий М.В. (17.12.2019, 20:01-20:03)
   ------------------------------------------------
   euler' n = length $ filter (== 1) 
                     $ map (\x -> gcd n x) [1..n]

   -- ***********************************************
   -- Демонстрация вычисления значения функции Эйлера
   -- в важном частном случае
   -- (э ф ф е к т и в н а я  реализация)
   --------------------------------------
   euler'' :: Integer -> Integer
   euler'' n | length z == 2 && p1/=p2 = n - p1 - p2 + 1
             | True                    = euler n
          where z  = expansion n
                p1 = head z
                p2 = head $ tail z

   -- *************************************************
   -- Демонстрация функции определения простоты числа n
   -- (н е э ф ф е к т и в н а я  реализация)
   ------------------------------------------
   simple n = euler n == n-1

   -- *******************************************
   -- Функция, конструирующая список сомножителей 
   -- в факторизации натурального числа
   -- (н е э ф ф е к т и в н а я  функция)
   ---------------------------------------
   expansion:: Integer -> [Integer]
   expansion 1 = []
   expansion n = x : expansion (quot n x)
      where primesBN = takeWhile (<= n) primes
            x        = head [y | y <- primesBN, mod n y==0]

   -- ******************************************************
   -- Функция, конструирующая простым перебором потенциально
   -- бесконечный список простых чисел 
   -- (н е э ф ф е к т и в н а я  функция)
   -------------------------------------------
   primes = 2 : [n | n <- [1,3..], isPrime1 n]
            where isPrime1 x = divisors x==[1]

   -- ******************************************
   -- Функция, конструирующая список собственных
   -- делителей натурального числа n
   ---------------------------------
   divisors:: Integer -> [Integer]
   divisors n = [x | x <- [1..n-1], rem n x==0]

   -- ***************************
   -- Неудачные тестовые примеры:
   -----------------------------------------
   test1 = map (\x -> (x,euler x))  [1..200]
   test2 = map (\x -> (x,euler' x)) [1..200]
   --------------------------------------------
   test3 = map (\x -> (x,length $ expansion x)) 
               [20001,20003..20999]
   test4 = take 25 $ map (\x -> (x,euler $ x-1)) primes
