> # Демонстрация криптосистемы RSA (учебный вариант):
> #
> #  (a,m) - открытый ключ;
> #    b   - закрытый ключ;
> #    m   - сообщение.
> #
> # Участники: {Алиса, Боб}; {Ева}.
> # Ева атакует систему RSA с помощью открытого ключа и шифртекста,
> # т.е. без прямой факторизации модуля r.
> #
> # Коллективное творчество 4-го курса ИС (11.10.2024, 12:00-13:02)
> # Описание действий Евы:  Швецкий М.В.  (14.10.2024, 18:47-20:21)
> # ***************************************************************
> restart; 
> with(numtheory):
> #
> # -------------------------------------
> # Выбор первого открытого ключа Боба...
> # —------------------------------------
> # p1:= nextprime(31231111111555555); 
>   p1:= nextprime(RandomTools[Generate](integer(range=3..10^18)));
> p2:= nextprime(3212133333777);  r:= p1*p2;
> #
> # -------------------------------------
> # Выбор второго открытого ключа Боба...
> # -------------—–-------------------------------------------
> a:= nextprime(31313131);  # Примитивный выбор этого ключа...
> igcd(a,phi(r));           # Проверка этого выбора...
> #
> # -------------------------------------------------
> # Вычисление закрытого ключа Боба, мультипликативно
> # обратного его открытому ключу (четыре способа):
> # -----------------------------------------------
> # t:= msolve(a*b=1,phi(r)); assign(t); b:= b;
>   igcdex(a,phi(r),'x','y');            b:= 1*x mod phi(r);
> # b:= a &^ (-1) mod phi(r);
> # b:= a &^ (phi(phi(r))-1) mod (phi(r));
> #
> # Этап распределения ключей закончен...
> #
> # ================================
> # Процесс передачи и приёма текста
> # --------------------------------
> m:= 10038042132;  # m<r
> printf("Проверка условия m<r: %d", r-m);
> # -------------------------------------------------
> m1:= m  &^ a mod r;  # Вычисление шифртекста Алисой
> m2:= m1 &^ b mod r;  # Выполнение дешифрования (первый способ)
> #
> printf("(0_1) Проверка результатов передачи: %d", m-m2); 
> #
> # ==================================================
> # Реализуем ускорение процесса дешифрования в 4 раза
> # с использованием китайской теоремы об остатках...
> # ----------------------------------------------------------
> mp1:= m1 &^ (b mod (p1-1)) mod p1:  # Закрытая экспонента...
> mp2:= m1 &^ (b mod (p2-1)) mod p2:  # Закрытая экспонента...
> # ----------------------------------------------------------
> m2_1:= (mp1*p2*(p2 &^ (-1) mod p1)          # Быстрое
>       + mp2*p1*(p1 &^ (-1) mod p2)) mod r;  # дешифрование...
> #
> printf("(0_2) Проверка результатов передачи: %d", m-m2_1);
> printf("\n\n"); 
> #
> # ******************************************************
> # На сцену выходит Ева и действует следующими способами:
> #
> # ------------------------------------------------
> # С п о с о б  N1 (Ева знает m1 и открытый ключ a,
> #                   а также узнала p1 или p2)...
> # -----------------------------------------------
> m3:= m1 &^ (a &^ (-1) mod ((p1-1)*(p2-1))) mod r;
> printf("(1) Проверка результатов передачи: %d", m-m3);
> #
> # ------------------------------------------------
> # С п о с о б  N2 (Ева знает m1 и открытый ключ a,
> #                  а также узнала phi(r))...
> # ------------------------------------------
> m4:= m1 &^ (a &^ (-1) mod phi(r)) mod r;
> printf("(2) Проверка результатов передачи: %d", m-m4);
> #
> # ------------------------------------------------
> # С п о с о б  N3 (Ева знает m1 и открытый ключ a,
> #                  а также узнала порядок order(m1,r))...
> # -------------------------------------------------------
> ord:= order(m1,r): 
> m5:= m1 &^ (a &^ (-1) mod ord) mod r;
> printf("(3) Проверка результатов передачи: %d", m-m5);
> #
> # --------------------------------------------------------------
> # С п о с о б  N4 (Ева знает m1 и открытый ключ a, а также нахо-
> #                  дит  порядок  некоторого  случайного числа a1
> #                  (order(a1,r)), а затем p1 и p2 по формулам:
> #                   p1:= igcd(a1^(r1/2)+1, r): 
> #                   p2:= igcd(a1^(r1/2)-1, r):
> # --------------------------------------------------------
> a1:= 2:             # Перебор всех значений a1<-[2,r-2]...
> while (a1 <= r-2) and (not p1*p2=r) do 
>    r1:= order(a1,r): p1:= igcd(a1^(r1/2) + 1, r):
>                      p2:= igcd(a1^(r1/2) - 1, r):
>    a1:= a1+1;
> end do;
> p1; p2;
> m6:= m1 &^ ((a &^ (-1)) mod ((p1-1)*(p2-1))) mod r;
> printf("(4) Проверка результатов передачи: %d", m-m6);
> #
> #
> # -----------------------------------------------------------
> # С п о с о б  N5 (Ева знает m1 и открытый ключ a; затем она:
> #          (а) шифрует собственный текст mEva открытым ключом a;
> #          (б) получает шифровку mEva1;
> #          (в) решает (!?) задачу дискретного логарифмирования
> #
> #              mEva= mEva1 ^ d (mod r) => d= log     mEva (mod r);
> #                                               mEva1
> #          (г) вычисляет m= m1 &^ d (mod r)...
> # --------------------------------------------
> mEva := 100;
> mEva1:= (mEva &^ a) mod r;
> z := mlog(mEva, mEva1, r);  # Ева вычислила закрытый ключ!
> m7:= mEva1 &^ z mod r;
> printf("(5) Ева проверяет правильность вычислений: %d", mEva-m7);
> # Теперь Ева "ломает" систему RSA...
> m8:= m1 &^ z mod r;
> printf("(6) Проверка результатов взлома: %d", m-m8);
> 
> 
> 
                              41019876016299781
                                3212133333781
                       131761311099520301039430201961
                                  31313141
                                      1
                                      1
                        64756675150146961333039136861
                                 10038042132
Проверка условия m<r: 131761311099520301029392159829
                        59697855864793267020017685579
                                 10038042132
(0_1) Проверка результатов передачи: 0
                                 10038042132
(0_2) Проверка результатов передачи: 0


                                 10038042132
(1) Проверка результатов передачи: 0
                                 10038042132
(2) Проверка результатов передачи: 0
                                 10038042132
(3) Проверка результатов передачи: 0
                              41019876016299781
                                3212133333781
                                 10038042132
(4) Проверка результатов передачи: 0
                                     100
                        33238884288189385329617171456
                        1072041452065310323253528801
                                     100
(5) Ева проверяет правильность вычислений: 0
                                 10038042132
(6) Проверка результатов взлома: 0
> 
