> # Демонстрация криптографических протоколов:
> #
> # (1) генерации ключей по методу RSA:
> #    (e, M) - открытый ключ,
> #    (d1,M) - закрытый ключ;
> #
> # (2) передачи и приёма текста по методу RSA;
> # 
> # (3) взлом криптосистемы с помощью удачной (повезло!)
> #     факторизации ключа M
> # ************************
> with(numtheory):
> #
> # -----------------------------------------------------
> # Выбор первого  о т к р ы т о г о  ключа M ("вручную")
> # -----------------------------------------------------
> p1:= nextprime(10131231241234564444444444); 
> p2:= nextprime(103312312312399999999);     # p1 и p2 закрыты... 
> M:= p1*p2; 
> ifactor(M); # Проверка выбора (практически нереализуемая операция!)
> #
> # ----------------------------------------------
> # Выбор  з а к р ы т о г о  ключа d1 ("вручную")
> # ----------------------------------------------
> d1:= nextprime(phi(M));
> igcd(d1,phi(M)); igcd(d1,(p1-1)*(p2-1)); # Проверка правильности
>                                          # выбора D1
> #
> # ------------------------------------------
> # Выбор о т к р ы т о г о  ключа e с помощью
> # закрытого ключа d1: это результат решения сравнения
> #
> #  d1*e=1 (mod phi(M))
> #
> # -------------------------------------------------------------------
> # e:= d1 &^ (phi(phi(M))-1) mod (phi(M));  # Важно, что (d1,phi(M))=1
> # e:= 'e'; t:= msolve(d1*e=1,phi(M)); assign(t); e:= e;  
>   e:= 'e'; t:= msolve(d1*e= 1,ilcm((p1-1)*(p2-1))); 
>                                       assign(t); e:= e;  # Внимание!
> # ------------------------------------------------------------------
> # Далее следует публикация ключа (e,M) (например, в Интернете)...
> # ---------------------------------------------------------------
> m:= 123456789 mod M;           # Шифруемый текст (важно, что m<M)
> #
> # =================================
> # Процессы передачи и приёма текста
> # --------------------------------------------
> m1:= m  &^ e  mod M;    # Зашифрованный текст, 
>                         # (ключ (e,m) находится у любого передающего)
> m2:= m1 &^ d1 mod M;    # Расшифрованный текст
>                         # (ключ d1 находится только у принимающего)
> # -----------------------------------------------------------------
> print("Result=", m-m2); # Проверка результата передачи текста
> #
> # =======================================================
> # На сцене появляется Ева, которая желает прочесть текст.
> # Предположим, что ей известны:
> #   (1) выбранный абонентами алгоритм RSA;
> #   (2) открытый ключ (e,M);
> #   (3) зашифрованное сообщение m1.
> #
> # Ева хочет узнать m2:= m1 &^ d1 mod M, а для этого она пы-
> # тается найти d1, решая сравнение 
> #
> #  d1*e=1 (mod phi(M)),
> #
> # но Еве неизвестна факторизация M (при этом Ева не обращает
> # внимания на то, что приступает к очень трудоёмкой задаче!) 
> # Действия Евы очевидны:
> s:= ifactors(M); p1:= s[2][1][1]; p2:= s[2][2][1];
> #
> # Контроль правильности выполненной факторизации и
> # лёгкое вычисление значения функции Эйлера:
> M:= p1*p2; phM:= (p1-1)*(p2-1);
> #
> # Вычисление закрытого ключа d1 и получение исходного текста:
> d1:= e &^ (phi(phM)-1) mod phM;
> m3:= m1 &^ d1 mod M;
> m3-m2;               # Проверка результата взлома
> #
> # =============================================================
> # Далее, появляется Ева_1, которая также желает прочесть текст.
> # Предположим, что ей известны:
> #   (1) выбранный абонентами алгоритм RSA;
> #   (2) открытый ключ (e,M);
> #   (3) зашифрованное сообщение m1;
> #   (4) значение phM функции Эйлера (удалось подсмотреть!).
> #
> # Ева_1 знает, что задача факторизации M  практически (т.е. в
> # данные временные сроки) неразрешима, но  она  умеет  решать
> # квадратные (!) уравнения. Поэтому действия Евы_1 очевидны:
> # ----------------------------------------------------------------
> x:= 'x'; s1:= isolve(x^2-(M-phM+1)*x+M= 0); assign(s1[1]); p1:= x; 
> x:= 'x';                                    assign(s1[2]); p2:= x;
> # 
> # Контроль правильности выполненной факторизации:
> p1*p2 - M; 
> #
> # Вычисление закрытого ключа d1 и получение исходного текста:
> d1:= e &^ (phi((p1-1)*(p2-1))-1) mod phM;
> m4:= m1 &^ d1 mod M;
> m4-m2;               # Проверка результата взлома
> #
                              1013123124123457
                            103312312312400000027
                    104668092610356980106106291151333339
                 (1013123124123457) (103312312312400000027)
                    104668092610356876792780855627209857
                                      1
                                      1
                                      e
                                   {e = 1}
                                      1
                                      e
                                   {e = 1}
                                      1
                                  123456789
                                  123456789
                                  123456789
                                "Result=", 0
          [1, [[1013123124123457, 1], [103312312312400000027, 1]]]
                              1013123124123457
                            103312312312400000027
                    104668092610356980106106291151333339
                    104668092610356876792780855627209856
                                      1
                                  123456789
                                      0
                                      x
             {x = 1013123124123457}, {x = 103312312312400000027}
                              1013123124123457
                                      x
                            103312312312400000027
                                      0
                                      1
                                  123456789
                                      0
> 
