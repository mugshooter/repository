> # Реализация алгоритма Диффи-Хеллмана, используемого
> # для передачи закрытого ключа, предназначенного для
> # будущего шифрования и дешифрования данных;
> # 
> #  (A,p,g) - открытый ключ абонента A;
> #  (B,p,g) - открытый ключ абонента B;
> #     a    - закрытый ключ абонента A;
> #     b    - закрытый ключ абонента B
> # ***********************************
> with(numtheory):
> # -----------------------------------------------
> # Генерация открытых чисел p и g для коммуникации
> # ---------------------------------------------------------------
> p:=17498005798264095394980017816940970922825355447145699491406164851279623993595007385788105416184430877;
> g:=4980057982640953976500178169262709228253554471452369503406164941279623993595307385078105416180853461;
> # -----------------------------------------
> # Генерация закрытого ключа абонента A
> a:=17498005798264095394980017816940970922825355447145699491406164851279623993595007385788105416184431367; 
> # ------------------------------------------
> # Вычисление открытого ключа абонента A
> A:= g &^ a mod p;
> # ------------------------------------
> # Генерация закрытого ключа абонента B
> b:=4374501449566023848745004454235242730706338861786424872851541212819905998398751846447026354046454419;
> # -----------------------------------------
> # Вычисление открытого ключа абонента B
> B:= g &^ b mod p;
> # ---------------------------------------------
> # Организация передачи информации: resA -> resB
> resA:= B &^ a mod p; 
> resB:= A &^ b mod p;
> # --------------------
> # Проверка вычислений:
> resA - resB;
> # -----------------------------------------------
> # Способ выполнения вычисления модульной степени:
> resA:= `mod`(B &^ a, p);
> #