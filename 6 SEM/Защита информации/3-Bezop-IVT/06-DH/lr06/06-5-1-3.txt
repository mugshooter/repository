> # Реализуйте с помощью системы символьных
> # вычислений Maple следующие протоколы:
> #
> # (3) шифра Эль-Гамаля.
> # 
> # Масолов Виссарион (4 курс, 04.12.2020)
> # ----------------------------------------------
> with(numtheory):
> # ----------------------------------------------
> # Для всей группы абонентов выбираются некоторое
> # большое простое число p и число g.
> # Числа p и g передаются абонентам в открытом
> # виде(они могут использоваться всеми абонентами
> # сети).
> # ----------------------------------------------
> p:=nextprime(12345); # Открытый ключ
> # ----------------------------------------------
> # PrimRoot
> # ----------------------------------------------
> z:=factorset(p-1); # Факторизация числа (p-1)
> lst:=[ ]; st:={ };
> for g from 2 to p-1
>   do
>     for i from 1 to nops(convert(z,list))
>       do
>         lst:=[op(lst), g &^ ((p-1)/z[i]) mod p];
>       end do;
>     if member(1,lst)
>       then lst:=[ ];
>       else st:={op(st),g}; lst:=[ ];
>     fi;
>   end do;
> g:=st[1]; # Открытый ключ
> # ----------------------------------------------
> # Затем каждый абонент группы выбирает своё
> # секретное число ci, 1<ci<p-1, и вычисляет с
> # оответствующий открытый ключ
> #
> # ci
> # di=g mod p.
> # ----------------------------------------------
> cA:=rand() mod (p-2); cA:=cA+1;
> dA:=g &^ cA mod p;
> #
> cB:=rand() mod (p-2); cB:=cB+1;
> dB:=g &^ cB mod p;
> # ----------------------------------------------
> # Покажем теперь, как A передаёт абоненту B
> # сообщение m.
> # Будем предполагать, что сообщение представлено
> # в виде числа m<p.
> #
> # Шаг 1. Абонент A формирует случайное число k,
> # 1 <= k <= p-2, и вычисляет числа
> #
> # k k
> # r=g mod p, e=m * dB mod p
> #
> # и пересылает пару (r,e) абоненту B.
> # ----------------------------------------------
> m:=12121; # Сообщение
> #
> kA:=rand() mod (p-3); kA:=kA+1;
> r:=g &^ kA mod p;
> eA:=(m * dB &^ kA) mod p;
> # ----------------------------------------------
> # Шаг 2. Абонент B, получив (r,e), вычисляет
> #
> # p-1-cB
> # m'=e * r mod p.
> # ----------------------------------------------
> m1:=(eA * r &^ (p-1-cB)) mod p;
> #
> printf("Результат (m - m1): %d", m-m1);
                           p := 12347
                         z := {2, 6173}
                           lst := []
                            st := {}
                             g := 2
                           cA := 8984
                           cA := 8985
                           dA := 5978
                           cB := 7590
                           cB := 7591
                          dB := 10687
                           m := 12121
                          kA := 10689
                          kA := 10690
                           r := 11514
                           eA := 5444
                          m1 := 12121
Результат (m - m1): 0
;
> 
;
