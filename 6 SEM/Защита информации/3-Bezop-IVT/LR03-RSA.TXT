    2УПРАЖНЕНИЕ 3.
    2АСИММЕТРИЧНАЯ КРИПТОГРАФИЯ: алгоритм и протокол RSA

 ш1.0
           1... едва ли разуму человека дано загадать такую  загадку,
           1которую  разум другого его собрата,  направленный должным
           1образом, не смог бы раскрыть. Прямо скажу, если текст за-
           1шифрован без грубых ошибок и документ в приличной сохран-
           1ности,  я больше ни в чем не нуждаюсь 0; 1  последующие труд-
           1ности для меня просто не существуют. 0
                                               1Эдгар По. Золотой жук
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Предварительные понятия . 0:
 ш1.0
    1- информационная безопасность 0;
    1- симметричные криптографические системы.

 ш1.2
    _ 1Основные понятия . 0:
 ш1.0
    1- криптосистема ограниченного использования 0;
    1- криптосистема общего использования 0:
      1- с секретным 0  1ключом 0;
      1- с открытым ключом  0( 1асимметричная система 0);
    1- криптографический протокол 0;
    1- односторонняя  0( 1однонаправленная 0) 1 функция 0;
    1- односторонняя функция с "лазейкой" 0;
    1- оцифровка 0;
   -  1алгоритм RSA, 0  1протокол RSA 0;
    1- протокол RSA с цифровой подписью 0;
   -  1протокол RSA без передачи ключа 0;
    1- 0  1алгоритмические аспекты организации 0  1RSA 0;
    1- генерация псевдослучайных чисел 0  1с использованием RSA 0;
    1- протокол Рабина 0.

    _ 1Уметь . 0:
    1- 0  1реализовать протокол RSA 0;
    1- реализовать протокол RSA без передачи ключей 0.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
   К основным проблемам  _ 1информационной безопасности . 0 (которым насчи-
тывается несколько тысяч лет) относятся следующие:
 ш1.1
   (1) сохранение информации в тайне;
   (2) передача информации адресату в тайне от других.

 ш1.2
    _ 1Способы решения проблем информационной безопасности . 0 можно услов-
но разбить на три группы [Утешев,Черкасов,Шапошников,2001,с.67]:
 ш1.1
   (1) создание абсолютно надёжного хранилища или недоступного  для
других канала связи между абонентами;
   (2) хранение информации в общедоступном месте или её передача по
общедоступному каналу связи  в   1преобразованном  виде 0:  так,  чтобы
восстановить её мог лишь тот, кому она предназначена.
   Этот способ решения основывается на построении  модели  передачи
информации по  1общедоступному каналу связи 0, которая называется  _ 1крип-
 _ 1тографической системой . 0;
   (3) маскировка или скрытие факта наличия информации или её пере-
дачи по общедоступному каналу связи; при этом разработкой средств и
методов  скрытия  факта  передачи  сообщения (тайнописи) занимается
 _ 1стеганография . 0.

 ш1.2
    2Определение 0 (по [Введение,1999,с.42]).
 ш1.1
   Под  _ 1протоколом . 0 (не обязательно криптографическим) обычно понима-
ют  1распределённый алгоритм 0, т.е. совокупность:
   (1) алгоритмов для каждого из участников;
   (2) спецификаций форматов сообщений, пересылаемых между участни-
ками;
   (3) спецификаций синхронизации действий участников;
   (4) описание действий при возникновении сбоев.

 ш1.2
    2Определение 0 [Словарь,2006].
 ш1.1
    _ 1Шаг протокола . 0 - это конкретное законченное действие, выполняемое
участником протокола во время одного цикла ( 1раунда 0) протокола (нап-
ример, вычисление значения некоторой функции,  генерация случайного
числа,  проверка правильности сертификата ключа, отправка сообщения
и т.п.).
 ш1.2

                   3Классификация криптографических
                               3систем

 ш1.0
                        1Я уже  не помню,  когда мне стало ясно,  что
                        1функцию можно обозначать не f 0( 1x 0) 1,  а f... Но
                        1даже когда мне это стало ясно,  я не отважи-
                        1вался последовательно проводить это в жизнь.
                                                       1Г.Фройденталь
 ш1.2

    2Определение 0 (по [Ростовцев,Маховенко,2001,с.10-11]).
 ш1.1
    2(1) 0  _ 1Криптосистема . 0 - это совокупность:
 ш1.0

    (а)  1криптографических алгоритмов 0;
    (б)  1криптографических протоколов 0 и способов их использования;
    (в)  1алгоритмов управления ключами 0, включающих создание, переда-
        чу (доставку), хранение, замену и уничтожение ключей.

 ш1.1
    2(2) 0  _ 1Криптографический алгоритм . 0 ( 1криптоалгоритм 0) - это  алгоритм,
реализующий  1криптографический протокол 0.
    2(3) 0  _ 1Криптографический протокол . 0 представляет собой распределённый
 1криптографический алгоритм 0 (т.е. алгоритм, выполняемый не менее чем
двумя сторонами), задаваемый последовательностью действий каждой из
сторон.

 ш1.2
    2Определение 0 (по [Брассар,1999,с.20]).
 ш1.1
    _ 1Криптосистемой ограниченного использования . 0 называется  1криптогра-
 1фическая система 0, стойкость которой основывается  на  сохранении  в
секрете самого характера алгоритмов шифрования и дешифрования.
   Подобные криптосистемы обычно разрабытываются  1любителями 0 и почти
всегда  являются  "детской  забавой" для опытного профессионального
криптоаналитика.
   Поэтому такие  системы не используются в ситуации,  когда должна
обеспечиваться работа большого количества пользователей.

 ш1.2
    2Определение 0 (по [Брассар,1999,с.20]).
 ш1.1
    _ 1Криптосистемой общего использования . 0 называется  1криптографическая
 1система 0, стойкость  которой основывается на секретности  некоторого
сравнительно короткого числового значения, называемого  _ 1ключом крип-
 _ 1тосистемы . 0.
   Такие ключи  должны  1легко 0 вырабатываться конкретными пользовате-
лями при помощи их  1собственных ключей 0 таким образом, чтобы при этом
даже разработчик  используемой криптосистемы не мог её раскрыть при
условии, что у него нет доступа к ключам, которые в ней используют-
ся.

 ш1.2
    1Криптосистемы общего использования 0 подразделяются на два класса:
 ш1.1
   (1)  1с секретным ключом 0;
   (2)  1с открытым ключом  0( 1ассиметричные криптосистемы 0).

 ш1.2
    2Определение 0 (по [Брассар,1999,с.22]).
 ш1.1
    _ 1Криптосистемой с секретным ключом . 0 называется  1криптосистема обще-
 1го использования 0, в которой  любые две стороны перед тем, как  свя-
заться  друг  с другом,  должны заранее договориться между собой об
использовании в дальнейшем некоторой информации  для  шифрования  и
дешифрования, хранящаяся в тайне часть которой называется  _ 1секретным
 _ 1ключом . 0.

 ш1.2
   Основная задача состоит в том,  что получателю и отправителю не-
обходимо согласовать секретый ключ таким образом,  чтобы он не стал
известным посторонним.  Если  же получатель и отправитель находятся
далеко друг от друга,  то возникает необходимость защитить ключ  от
перехвата при передаче, ибо, перехватив ключ при передаче, злоумыш-
ленник получает возможность читать,  изменять и подделывать сообще-
ния, зашифрованные или подписанные этим ключом.
   Поскольку ключи должны оставаться засекреченными, то при исполь-
зовании криптосистем с секретным ключом возникает необходимость  _ 1за-
 _ 1щищённого управления ключами . 0, особенно  в открытых системах с боль-
шим количеством пользователей.
   Таким образом,
 ш1.0

    4┌ 0────────────────────────────────────────────────────────── 4┐
   │ 1если вы хотите зашифровать собственные файлы, то это лучше 0│
   │ 1выполнить с помощью симметричной криптосистемы, где пароль 0│
   │ 1используется как секретный ключ 0.                          │
    4└ 0────────────────────────────────────────────────────────── 4┘

 ш1.2
   Перечислим наиболее известные  _ 1криптографические системы  с  сек-
 _ 1ретным 0  1ключём . 0:
 ш1.1
   -  1блочные шифры 0  : Магма, RC6, Rijndael (AES), "Кузнечик";
   - 1 потоковые шифры 0: RC4, HC-128.

 ш1.2
   Эти шифры  являются  вычислительно  стойкими шифрами с секретным
ключом, которые,  в принципе,  могут быть вскрыты,  но требуют  для
этого очень большого количества вычислений, скажем, 10 520 0 лет работы
супркомпьютера.
   Теперь же, когда криптография стала общедоступной, неразумно ор-
ганизовывать подобные коммуникационные сети,  в которых каждой паре
потенциальных пользователей заранее предоставляется  их  совместный
секретный ключ,  т.к.  в такой сети количество ключей возрастало бы
 1квадратично 0 ( 1почему 0?) с увеличением числа пользователей.
   Поэтому часто используются  _ 1криптографические системы с  открытым
 _ 1ключём . 0, в которых каждый пользователь получает пару ключей:
 ш1.1
   -  _ 1открытый ключ . 0, которым информация зашифровывается;
   -  _ 1закрытый . 0 (секретный)  _ 1ключ . 0,  с помощью которого информация рас-
шифровывается.

 ш1.2
   Открытый ключ публикуется открыто,  но открытый ключ должен быть
строго связан с его владельцем (например,  в  1официальном справочни-
 1ке 0); закрытый же ключ сохраняется владельцем в секрете и не пересы-
лаются. Именно поэтому криптосистемы с  открытым  ключом  позволяют
использовать незащищённые каналы.
   Каждый пользователь криптосистемы может  посылать  зашифрованное
сообщение, используя для этого открытые ключи адресатов, но расшиф-
ровать такое сообщение может только обладатель закрытого ключа.
   Перечислим наиболее известные  _ 1криптографические системы с откры-
 _ 1тым ключём . 0:  1Диффи-Хеллмана 0,  1Эль-Гамаля 0,  1RSA 0,  1на основе  эллиптичес-
 1ких кривых 0.
   Современные асимметричные криптосистемы  _ 1не могут . 0 полностью заме-
нить  1симметричные криптосистемы 0 в силу следующих обстоятельств  (по
[Хорев,2005,с.147]):
 ш1.1
   (1) большая продолжительность процедур шифрования и  расшифрова-
ния (примерно в 1000 раз больше);
   (2) необходимость использования существенно более длинного ключа
шифрования для обеспечения такой же  _ 1криптостойкости шифра . 0 (?!).
   Например,  1симметричному ключу 0 длиной 56 битов будет соответство-
вать  1асимметричный ключ 0 длиной 384 бита, а  1симметричному ключу 0 дли-
ной 112 битов -  1асимметричный ключ 0 длиной 1792 бита.

 ш1.2
    3Замечания 0.
 ш1.1
    21. 0  _ 1Криптосистема . 0 ( 1секретная система 0,   1система защиты информации 0)
определяется как некоторое множество отображений одного  пространс-
тва ( 1множество возможных сообщений 0) в другое пространство ( 1множест-
 1во возможных криптограмм 0).  Каждое конкретное отображение из  этого
множества соответствует  способу  шифрования при помощи конкретного
ключа.
    22. 0 Все операции, на которые сейчас опирается криптография с отк-
рытым ключом ( 1умножение 0,   1возведение в степень 0 и  1разложение на мно-
 1жители 0) представляют собой арифметические операции.
    23. 0 В настоящее время алгоритм RSA реализуется как в виде  самос-
тоятельных криптографических продуктов, так и в качестве встроенных
средств в популярных приложениях.
    _ 1КриптоAPI . 0 [Словарь,2006]  - это криптографический протокол прик-
ладного программирования, определяющий порядок обращения прикладных
программ  к  библиотеке функций/программ,  реализующих элементарные
криптографические функции и операции.
 ш1.2

                      2Криптографические функции

 ш1.0
                                 1Камень, который отвергли строители,
                                 1соделался главою угла... 0
                                                          1Пс. 117 0: 122
 ш1.2

    1У.Диффи 0 ( 1B.W.Diffie 0) и  1М.Хеллман 0 ( 1M.E.Hellman 0) выдвинули  (1976)
идею построения  _ 1криптосистемы с открытым ключом . 0, которая не требует
передачи ключа принимающему сообщение,  а также сохранения в  тайне
метода шифрования. Эта идея не только существенно изменила криптог-
рафию, но и привела к появлению новых результатов в математике.
   Опишем два понятия, которые являются центральными для криптогра-
фии с открытым ключом:
 ш1.1
   (1)  1односторонние 0 ( 1однонаправленные 0,   1вычислительно-необратимые 0)
 1функции 0;
   (2)  1односторонние 0  ( 1однонаправленные 0)  1функции с  0" 1лазейкой 0" ( 1сек-
 1ретом, потайным ходом, ловушкой 0).
 ш1.2

                      21. 0  3Односторонние функции

 ш1.0
            1Односторонние улицы - это то,  чем занимается криптогра-
            1фия с открытым ключом. Вот один из очень типичных приме-
            1ров 0: 1  устройство,  являющееся  ловушкой для ловли рыбы в
            1северных странах.  Рыбе очень легко забраться в  клетку.
            1Форма входа ведёт рыбу внутрь - здесь в качестве приман-
            1ки может находиться маленькая рыбка.  С другой  стороны,
            1рыбе  очень  трудно  найти  путь назад,  хотя в принципе
            1бегство возможно.  Легальный пользователь,  т.е.  рыбак,
            1берёт рыбу через отверстие в верхней части клетки. 0
                           1А.Саломаа. Криптография с открытым ключом
 ш1.2

   Рассмотрим функцию y= ═f 0(x), определённую на множестве A и отобра-
жающую это множество в множество B, т.е.  ═f 0:A 76 0B.
   Говоря далее об обратимости функции  ═f 0(x), будем иметь в виду:
 ш1.1
   (1) либо задачу определения всех прообразов данного значения y 7е 0B
этой функции;
   (2) либо задачу нахождения какого-то одного прообраза.

 ш1.2
   Другими словами, речь идёт об  1инвертировании функции 0, т.е. поис-
ке решений уравнения  ═f 0(x)=y относительно x 7е 0A при заданном y 7е 0B.
    2Определение 0.
 ш1.1
    _ 1Инвертированием функции . 0  ═f 0 называется решение  задачи  нахождения
по  заданному значению функции  ═f 0  _ 1одного . 0 (любого) значения из прооб-
раза (при этом обратная функция может и не существовать).

 ш1.2
    2Определение 0  21 0.
 ш1.1
    _ 1Односторонней функцией . 0  называется  функция  y= ═f 0(x),  обладающая
следующими свойствами:
   (1)  _ 1простота .  вычислений 0:  для  любого x 7е 0A значение функции  ═f 0(x)
вычисляются просто;  другими словами, существует  1полиномиальный ал-
 1горитм вычисления значений 0  ═f 0(x);
   (2) 1  _сложность . обращения 0:  для практически всех значений y 7е 0B  на-
хождение  хотя бы одного прообраза представляет вычислительно очень
трудоёмкую задачу;  другими словами не  существует   1полиномиального
 1алгоритма инвертирования функции  ═f 0 (относительно x).

 ш1.2
   Разумеется, что  слова " 1сложность 0" и " 1простота 0" требуют дополни-
тельных пояснений. Кратко их можно формализовать в терминах извест-
ных алгоритмов, допускающих компьютерную реализацию.
    2Пример 0 (по [Утешев,Черкасов,Шапошников,2001,с.76]).
 ш1.1
   Пусть A  ═+ 0 {1,2,...,16}.
   Рассмотрим функцию y= ═f 0(x):A 76 0A, где  ═f 0(x)  ═+ 0 3 5x 0  1mod 0 17, представимую
в виде следующей таблицы:
 ш1.0

   ┌───╥─┬─┬──┬──┬─┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
   │ x ║1│2│ 3│ 4│5│ 6│ 7│ 8│ 9│10│11│12│13│14│15│16│
   ├───╫─┼─┼──┼──┼─┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
   │  ═f 0 ║3│9│10│13│5│15│11│16│14│ 8│ 7│ 4│12│ 2│ 6│ 1│
   └───╨─┴─┴──┴──┴─┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘

   Например,  ═f 0(5)= 3 55 0  1mod 0 17 = 243 ( 1mod 0 17) = 5.

 ш1.1
   Конечно, существует обратная функция   1ind 43 0y ( 1индекс числа 0   1y  по
 1модулю 17 и основанию 3 0),  которую легко построить, имея перед гла-
зами только что выписанную таблицу.
   Однако построить такую таблицу для больших простых чисел p  (по-
рядка 10 560 0) нереально,  но в настоящее время не известен  _ 1иной . 0 алго-
ритм алгоритм вычисления индексов (другими словами, решение   1задачи
 1дискретного логарифмирования 0).

 ш1.2
    2Определение 0  22 0 (по [Словарь,2006]).
 ш1.1
    2(1) 0  _ 1Односторонней . 0 ( 1однонаправленой 0)  _ 1функцией . 0 называется  отобра-
жение множества всех слов конечной длины n над конечным  алфавитом,
для которого:
   (1) существует такое 7 g 0< 7$ 0,  что образ любого слова длины n  можно
вычислить за  7O 0(n 7П 0) операций;
   (2) ни для какого 7 b 0< 7$ 0 не существует алгоритма,  вычисляющего для
любого слова длины n его прообраз по его образу за  7O 0(n 7И 0) операций.
    2(2) 0  _ 1Односторонней функцией . 0 называется  1эффективная 0  функция,  для
которой не известен  1эффективный 0 алгоритм обращения.
 ш1.0

    4┌ 0──────────────────────────────────────────────────────── 4┐
   │Вопрос о существовании односторонних функций пока  _ 1открыт . 0│.
    4└ 0──────────────────────────────────────────────────────── 4┘

 ш1.2
    3Замечания 0 ( 1важные 0).
 ш1.1
    21. 0 Доказательство односторонности какой-либо функции означало бы
доказательство гипотезы P 7- 0NP в теории сложности алгоритмов.
    22. 0 Понятие " 1односторонняя функция 0", используется при конкретиза-
ции определения  1стойкости асиметричных криптографических систем 0.
 ш1.2

                      22. 0  3Односторонние функции
                            3с "лазейкой"

 ш1.0
        1Он встроил в систему  классическую  дверцу-ловушку.  Вообще,
        1вряд  ли  кто-нибудь из программистов,  создававших обширные
        1компьютерные системы,  мог бы удержаться от искушения  оста-
        1вить маленькую тайную лазейку - дополнительный доступ к сис-
        1теме для собственного использования.  Отчасти это нужно было
        1на тот случай, если неумелые пользователи как-нибудь случай-
        1но заблокируют систему,  а потом вызовут программиста её чи-
        1нить  -  таким образом у создателя системы всегда будет воз-
        1можность влезть внутрь неё и исправить неполадки.  А отчасти
        1это было всё равно что подпись художника под картиной... 0
                                     1М.Крайтон. Парк юрского периода
 ш1.2

    2Определение 1 0.
 ш1.1
    2(1) 0 [Утешев,Черкасов,Шапошников,2001,с.76]  _ 1Односторонняя функция
 _ 1с  0" 1лазейкой 0" . (англ.  1trapdoor function 0) - это  1односторонняя функция 0,
обладающая тем свойством, что при некоторой дополнительной информа-
ции о функции  ═f 0(x), обращение этой функции становится  1простой зада-
 1чей 0.
    2(2) 0 [Словарь,2006]  _ 1Функция с секретом . 0 (англ.   1trapdoor function 0)
- это дискретная функция, зависящая от параметра ( 1секрета 0, описания
секрета).
   Знание параметра  позволяет  эффективно  (т.е.  с полиномиальной
сложностью) вычислять и инвертировать данную функцию.
   Если же параметр неизвестен, то не существует эффективного алго-
ритма инвертирования функции.
   Семейство функций  с  секретом обладает свойствами  1односторонней
 1функции 0.

 ш1.2
    2Определение 0  22 0 [Введение,1999,с.18].
 ш1.1
    _ 1Функция с секретом . k 0 - это функция  ═f 4k 0:X─ 76 0Y, зависящая  от  пара-
метра k и обладающая свойствами:
   (а) существует полиномиальный алгоритм вычисления значения  ═f 4k 0(x)
для любых k и x;
   (б) не существует полиномиального алгоритма инвертирования  ═f 4k 0(x)
при  _ 1неизвестном . 0 k;
   (в) существует полиномиальный алгоритм инвертирования  ═f 4k 0(x)  при
 _ 1известном . 0 k.

 ш1.2
    3Замечания 0.
 ш1.1
    21. 0 [Шнайер,2002,с.47] Наглядным примером однонаправленной  функ-
ции с потайным входом является процесс разборки часов: часы нетруд-
но разобрать на сотни крохотных деталей, но  1очень сложно 0 собрать из
них работающие часы.
   Однако с  помощью   1инструкции  по  сборке 0 (секретной информации)
справиться с этой задачей трудно, но намного легче.
    22. 0 [Утешев,Черкасов,Шапошников,2001,с.77] Для пояснения идеи од-
носторонней функции с "лазейкой" обратимся к истории.
   Противник ведёт  осаду  неприступной крепости.  Фортификационные
особенности допускают единственную тактику  приступа:  штурм  мощно
укреплённых ворот "в лоб". Однако имеется  1секретный лаз 0, ведущий из
крепости к какому-то укромному месту за её пределами - например,  к
реке. Через лаз любой защитник крепости может незаметно для окружа-
ющих покинуть её пределы.
   (Вспомним, например, известную сцену осады запорожцами польского
города Дубно из повести Н.В.Гоголя "Тарас Бульба".)
   Для осаждающих имеются две возможности проникновения в крепость:
   (а) прямой кровопролитной атакой ворот;
   (б) через секретный лаз (если,  разумеется, этот лаз удастся об-
наружить). Тогда достаточно просочиться в крепость небольшой группе
диверсантов, чтобы, перебив внезапным нападением охрану ворот, отк-
рыть их основным силам штурмующих.
   Итак, как для защитников крепости, так и для осаждающих  _ключ .евой
является информация о  1секретном лазе 0.                          ═О 4!

 ш1.2
   Для практических  целей  криптографии  было  построено несколько
функций, которые могут оказаться функциями с "лазейкой".
   Для них свойство (в) пока не доказано,  но считается, что задача
инвертирования эквивалентна некоторой  1давно изучаемой трудной мате-
 1матической задаче 0.
   Например, в настоящее время известен единственный алгоритм быст-
рого обращения степенной функции
 ш1.0

    4┌ 0─────────── 4┐
   │y= x 5n 0  1mod 0 m│,
    4└ 0─────────── 4┘

 ш1.2
т.е. вычисления корня степени n по модулю m,  и этот алгоритм пред-
полагает  _ 1знание канонического разложения . 0  1m 0.
   Если модуль  m является произведением различных простых и доста-
точно больших (порядков 10 580 0) множителей, и  _ 1эти множители известны . 0,
то обращение функции y=x 5n 0 (mod m) не составит значительной вычисли-
тельной трудности.
   Если  _ 1эти множители заранее не известны . 0,  то практически для всех
значений y 7е 0{0,1,...,m-1} (с использованием современных вычислитель-
ных мощностей) крайне трудно решить относительно x  1сравнение 0
 ш1.0

   y 7= 0x 5n 0 (mod m).

 ш1.2
   Например, если множители имеют длину порядка 100 десятичных цифр,
то в наилучшем из известных способов разложения на множители необхо-
димо порядка 100 млн. лет компьютерных вычислений.
    3Замечание 0 ( 1важное 0).
 ш1.1
    1Секретной "лазейкой" для односторонней функции 0 y=x 5n 0  1mod 0 m  явля-
ется структура канонического разложения m.

 ш1.2
    2Определение 0 ( 1повторение 0).
 ш1.1
    _ 1Дискретным логарифмированием . 0 называется инвертирование функции
 ш1.0

   y= a 5x 0  1mod 0 m.

 ш1.2
   Пока у математиков создаётся впечатление о том,  что  дискретное
логарифмирование является трудной вычислительной задачей.
   Применение в криптографии функций с "лазейкой" позволяет:
 ш1.1
   (1) организовать обмен шифрованными сообщениями с использованием
только  1открытых каналов связи 0, т.е. отказаться от секретных каналов
связи для предварительного обмена ключами.
   Опишем идею реализации этого пункта.
   Пользователь B, который  хочет получать  шифрованные  сообщения,
выбирает какую-нибудь функцию  ═f 4k 0 с секретом k и сообщает (например,
публикует)  всем  заинтересованным  описание  функции  ═f 4k 0 в качестве
своего алгоритма шифрования,  однако при этом значение k держится в
тайне.
   Если теперь пользователь A хочет послать пользователю B защищае-
мую информацию x 7е 0X,  то он вычисляет y= ═f 4k 0(x) и посылает y по откры-
тому каналу пользователю B.  Поскольку B для своего секрета k умеет
инвертировать  ═f 4k 0, то он вычисляет x по полученному y.
   Никто другой  не  знает  k  и поэтому (в силу свойства функции с
секретом) не сможет за полиномиальное время по известному шифрован-
ному сообщению  ═f 4k 0(x) вычислить защищаемую информацию x;
   (2) свести решение задачи вскрытия шифра к решению трудной мате-
матической задачи и тем  самым  повысить  обоснованность  стойкости
шифра;
   (3) решать  криптографические  задачи,  отличные  от  шифрования
(примером является  1электронная цифровая подпись 0).

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Применение функции с секретом предполагает построение  соответс-
твующего  _ 1генератора функций с секретом . 0,  т.е. эффективного алгорит-
ма, порождающего пары вида
 ш1.0

   ( 1Функция 0,  1Секрет 0) 1.
 ш1.2

                     2Алгоритм RSA и протокол RSA

 ш1.0
                                     1Над небом голубым
                                     1Есть город золотой
                                     1С прозрачными воротами
                                     1И яркою стеной.
                                           1Автор слов 0: 1 А.Волхонский,
                                           1автор музыки 0: 1 В.Вавилов
 ш1.2

   Криптосистема RSA (разработана в 1977) названа по первым  буквам
фамилий  её создателей  1Р.Ривеста 0 (R. 3R 0ivest),  1А.Шамира 0 (A. 3S 0hamir)  и
 1Л.Эделмана 0 (L. 3A 0dleman).
    3Замечание 0 ( 1с точки зрения истории криптографии 0)
             (по [Сингх,2007,с.314-328]).
 ш1.1
    21. 0  _ 1Джеймс Эллис . 0 (конец 1969 г.)  придумал  идею  криптографии  с
открытым ключом (он называл её " 1несекретным шифрованием 0").
   Оставалось только придумать одностороннюю функцию с "лазейкой".
   Много лет спустя Дж.Эллис записал тот миг,  когда обнаружил, что
распределение ключей не является обязательной частью криптографии:
   "... я  нашёл  подготовленный в военное время отчёт неизвестного
автора из компании Белл Телефон,  в котором описывалась  остроумная
идея, как обезопасить телефонные разговоры.
   Предлагалось, чтобы тот,  кто слушает, маскировал речь говоряще-
го,  создавая шум в линии. Потом он смог бы отсечь шум, так как это
он создал его и потому знает,  каков он. Использовать такую систему
не  позволили  её очевидные практические недостатки,  но в ней было
несколько интересных моментов.  Разница между этой системой и обыч-
ным  шифрованием  заключалась в том,  что в данном случае тот,  кто
слушает, участвует в процессе шифрования... Так родилась идея".
    22. 0  _ 1Клиффорд Кокс . 0 (1973 г.) изобрёл  алгоритм,  впоследствие  на-
званный RSA, предложив  одностороннюю функцию с "лазейкой", сущест-
венно использующий факторизацию.
   К.Кокс объясняет:  "Поскольку я работал в области теории  чисел,
было вполне естественно, что и думать я стал об односторонних функ-
циях,  с помощью которых вы можете что-то сделать, но вернуться об-
ратно  уже  не  удастся.  Явными кандидатурами были простые числа и
разложение на множители, и это стало моей отправной точкой".
   Далее К.Кокс вспоминает: їОт начала и до конца это заняло у меня
не более  _ 1получаса . 0.  Я был вполне доволен собой.  Я думал:  "О,  это
здорово. Мне дали задачу, и я решил её"Ї.
   Однако эти открытия были засекречены, т.к. эти учёные работали в
 1Штаб-квартире правительственной связи 0 (Великобритания, Челтенхем) -
спецслужбе, ответственной за разведку средств связи.
    23. 0  _ 1Закон Стиглера об эпонимии . 0 ( 1Stigler 0,  1980). Ни одно  научное
открытие не названо в честь его первооткрывателя.
   Этот закон применим к самому себе,  т.к. был впервые сформулиро-
ван Р.Мертоном.
   Следствием этого закона является то, что если  _ 1все . 0 (!) согласятся
по поводу настоящего автора открытия, то закон вообще не будет пои-
менован в пользу какого-либо имени.

 ш1.2
                          21. 3 Идея алгоритма
   Покажем, как использовать одностороннюю функцию с "лазейкой" для
решения проблемы шифрования.
   В качестве такой функции, действующей на множестве
 ш1.0

   A  ═+ 0 {0,1,2,...,m-1},

возьмём степенную функцию

    ═f 0(x)= x 5e 0  1mod 0 m

 ш1.2
при некотором фиксированном показателе e и некотором  _ 1составном . 0  мо-
дуле m.  При  определённых  условиях на указанные числа эта функция
взаимно-однозначно отображает множество A в себя и тогда с  её  по-
мощью зашифруем  1открытый текст 0 x 40 7е 0A (разумеется,  текст должен быть
предварительно закодирован натуральным числом):
 ш1.0

   c=  ═f 0(x 40 0)= x 40 5e 0  1mod 0 m.

 ш1.2
   В этом случае декодирование сообщения c= ═f 0(x 40 0) сводится к решению
сравнения x 40 5e 7= 0c (mod m), которое имеет единственное решение x 40 7е 0A.
    3Замечание 0 [Земор,2006,с.46].
 ш1.1
   Во французском языке слово " 3c 1hiffre 0" может обозначать как   1шифр 0,
так и 1 цифру 0.
 ш1.2

                      22. 3 Алгоритм распределения
                             3ключей RSA

 ш1.0
                1- Ступай скорее вниз,  в долину,  в хижины людей,  и
                1достань у них Красный Цветок. У тебя будет тогда со-
                1юзник сильнее меня, и Балу, и тех волков Стаи, кото-
                1рые любят тебя. Достань Красный Цветок 0! 1...
                1- Не забудь,  что этот  цветок  растёт  в  маленьких
                1горшках.  Добудь  же  его поскорее и держи при себе,
                1пока он не понадобится.
                                                   1Р.Киплинг. Маугли
 ш1.2

    2Определение 0 [Ростовцев,Маховенко,2001,с.227].
 ш1.1
    _ 1Система распределения ключей . 0 - это соглашение, при котором дове-
ренный  _ 1центр распределения ключей . 0 генерирует и распределяет секрет-
ные данные между пользователями так, что любые две из них могут ус-
тановить свой секретный ключ, недоступный для остальных пользовате-
лей6 за исключением центра.

 ш1.2
   Приведём   _ 1алгоритм . 0  1RSA 0  _ 1построения ключей шифрования и дешифрова-
 _ 1ния . 0 (по [Утешев,Черкасов,Шапошников,2001,с.80]):
 ш1.1
   (1) случайным  образом выбираются два достаточно большие простые
числа p 41 0 и p 42 0 и вычисляется их произведение:
 ш1.0

   m= p 41 77 0p 42 0,

 ш1.2
при этом число m  _ 1открыто . 0 (не скрывается), однако множители  p 41 0 и p 42
являются  _ 1секретными . 0;
   (2) случайным  образом  выбирается  достаточно  большое  число 3 d
(от англ.  3d 1ecription 0 -  1дешифрование 0), взаимно простое с
 ш1.0

    7f 0(m)= (p 41 0-1)(p 42 0-1), т.е. ( 3d 0, 7f 0(m))=1.

 ш1.2
   Число  3d 0 является  _ 1закрытым . 0 (или  _ 1секретным . 0);
   (3) вычисляется число  3e 0 (от англ.  3e 1ncription 0 -  1шифрование 0), муль-
типликативно обратное  3d 0 по модулю  7f 0(m), как решение сравнения
 ш1.0

    3d 77 3e 7= 01 (mod  7f 0(m)).

 ш1.2
   Решение существует и единственно, в силу того, что ( 3d 0, 7f 0(m))=1.
   Число  3e 0 является  _ 1открытым . 0.
   Теперь:
 ш1.1
   - пара ( 3e 0,m) составляет  _ 1открытый ключ . 0 (или  _ 1ключ шифрования . 0), ко-
торый не является  1единственным 0;
   - пара ( 3d 0,m) составляет  _ 1закрытый ключ . 0 (или  _ 1ключ дешифрования . 0).

 ш1.2
    3Замечания 0.
 ш1.1
    21. 0 Иногда  _ 1закрытым ключём . 0 называют кортеж  ═< 0p 41 0,p 42 0, 7f 0(m), 3d ═> 0.
   Однако числа p 41 0, p 42 0,  7f 0(m) в дальнейшем не используются, т.к. для
дешифрования достаточно знать пару ( 3d 0,m).
    22. 0 [Утешев,Черкасов,Шапошников,2001,с.111]
   В алгоритме  построение  ключей  шифрования  и  дешифрования RSA
предлагалось вначале выбрать ( 1почти 0 произвольным образом) ключ  де-
шифрования   3d 0, а уже с его помощью вычислить  ключ шифрования  3e 0 как
решение сравнения  3d 77 3e 7= 01 (mod  7f 0(m)).
   Ввиду симметричности этого сравнения относительно чисел   3e 0  и 3  d
возможно "обращение" последовательности выбора  3d 0 и  3e 0, т.е. возможно
выбрать вначале  3e 0, а затем с его помощью вычислить  3d 0.
   Эта возможность иногда оправдана тем, что выбор небольшого пока-
зателя  3e 0 может облегчить процедуру шифрования для корреспондентов.
   Действительно, с точки зрения стойкости  для  криптоанализа  для
модулей m 7. 010 5155 0 совершенно  3" 0равнотруден 3" 0 выбор в качестве показате-
ля шифрования
 ш1.0

    3e 0= 3,  3e 0= 17,  3e 0= 2 516 0+1= 65537,  3e 0= 876125345816781182489.

 ш1.1
   Например, двоичное представление 65537 содержит только две  еди-
ницы, поэтому  для  возведения  в степень нужно выполнить только 17
умножений.
 ш1.2

                           23. 3 Алгоритм RSA

 ш1.0
           1Мы находимся в положении, несколько аналогичном положению
           1человека,  держащего  в руках связку ключей и пытающегося
           1открыть одну за другой несколько дверей.  Рано или поздно
           1ему  всегда удается подобрать ключ к очередной двери,  но
           1сомнения  относительно  взаимнооднозначного  соответствия
           1между ключами и дверями у него остаются. 0
                                                            1Ю.Вигнер
 ш1.2

    2Теорема 0 ( 1основная 0)
           (по [Утешев,Черкасов,Шапошников,2001,с.81-82]).
 ш1.1
   Пусть число  3e 0 выбрано с помощью  1алгоритма построения ключей RSA 0.
   Тогда сравнение с неизвестной x 7е 0{0,1,...,m-1}
 ш1.0

    4┌ 0────────────── 4┐ 0                             4┌ 0────────────── 4┐
   │x 5e 0  7= 0 c (mod m)│ имеет  1единственное 0 решение │x  7= 0 c 5d 0 (mod m)│.
    4└ 0────────────── 4┘ 0                             4└ 0────────────── 4┘

 ш1.2
    2Доказательство 0. Вначале вспомним, что
 ш1.0

    3d 77 3e 7= 0 1 (mod  7f 0(m)) =>  3d 77 3e 0= 1 + k 77f 0(m), k 7е ═Z 0.

 ш1.2
   Покажем, что пара ( 3e 0, 3d 0), полученная с помощью алгоритма построе-
ния ключей RSA, обладает  1свойством обратимости 0:
 ш1.0

   c 7= 0 x 5e 0 (mod m) => c 5d 7= 0 x 5de 0 (mod m).

 ш1.2
   Рассмотрим три случая.
    21. 0 (x,m)=1. Тогда по  _ 1теореме Эйлера
 ш1.0

             1+k 77f 0(m)     4┌ 0  7f 0(m) 4┐ 0k
   c 5d 7= 0 x 5ed 7= 0 x         7= 0 x 772 0x     72 0  7= 0 x 77 01 (mod m) 7= 0x (mod m).
                          4└ 0      4┘

 ш1.2
    22. 0 (x,m)>1. При x=0 сравнение очевидно, поэтому x 7- 00.
   Поскольку число m является произведением двух различных  простых
чисел p 41 0 и p 42 0, то (x,m) должен совпадать с одним из них.
   Пусть для определённости (x,m)=p 41 0, т.е. x 7= 00 (mod p 41 0).
   Тогда при любом числе Q 7е ═N 0 будет справедливо
 ш1.0

   x 5Q 7= 0 x (mod p 41 0),

т.е. и при Q  ═+ 0 e 77 0d, а именно:

   x 5ed 7= 0 x (mod p 41 0).

 ш1.2
   Поскольку x не может делиться ещё и на p 42 0, то на основании  _ 1малой
 _ 1теоремы Ферма . 0 получим:
 ш1.0

    p 42 0-1
   x     7= 0 1 (mod p 42 0), (x,p 42 0)=1.

 ш1.2
   Возводим это сравнение в степень k(p 41 0-1) и умножаем на x:
 ш1.0

    4┌ 0 (p 42 0-1) 4┐ 0k(p 41 0-1)                  k 77f 0(m)
   │x      │        7= 0 1 (mod p 42 0) <=> x       7= 0 1 (mod p 42 0) <=>
    4└ 0        4┘
                       1+k 77f 0(m)
                  <=> x         7= 0 x (mod p 42 0) <=> x 5ed 7= 0 x (mod p 42 0).

 ш1.2
   Остаётся, используя свойства сравнений, получить:
 ш1.0

   x 5ed 7= 0 x (mod p 41 0), x 5ed 7= 0 x (mod p 42 0) => x 5ed 7= 0 x (mod m).

 ш1.2
    23. 0 Пусть и p 41 0, и p 42 0 являются делителями x, но по условию x<m.
   Остаётся открытым  вопрос  1однозначности 0 дешифрования:  вдруг су-
ществует x 41 7- 0x такое, что
 ш1.0

   c 7= 0 x 41 5e 0 (mod m)?

 ш1.2
   Решите эту проблему  1самостоятельно 0.
    1Теорема доказана 0.
   Из "конструктивной"  формулировка теоремы получается простой ал-
горитм: если сообщение x зашифровано с помощью ключа e, т.е.
 ш1.0

   c 7= 0 x 5e 0 (mod m),

то ключ  3d 0 выполняет правильную дешифровку, т.е.

   x 7= 0 c 5d 0 (mod m).

 ш1.2
   Принципиальной особенностью этого алгоритма является  открытость
ключа шифрования для любого желающего: пара (m, 3e 0) считается доступ-
ной даже для  1криптоаналитика 0, взламывающего переписку.
   Любой желающий может зашифровать свой открытый текст нашим  шиф-
ром.  Но вот дешифровать чужой текст,  зашифрованный тем же шифром,
ему будет значительно труднее, т.к. каноническое разложение  m  из-
вестно только (!) нам.
                  3Работа с примерами решённых задач
 ш1.1
   См. Пример 1, Пример 4.

 ш1.2
   Приведём  _ 1практические рекомендации по выбору параметров алгорит-
 _ 1ма . 0  1RSA 0.
   Если n - произведение двух  _ 1простых . 0 (!) чисел p 41 0 и p 42 0,  то в  ка-
честве  p 41 0 и p 42 0 иногда используются  _ 1сильные простые числа . 0,  которые
характеризуются рядом свойств,  усложняющих разложение на множители
произведения n специальными методами.
    2Определение 0 (по [Шрейдер,2001,с.300]).
 ш1.1
    _ 1Сильными простыми числами . 0 называются простые числа p 41 0 и p 42 0,  до-
полнительно удовлетворяющие следующим условиям:
 ш1.0

   (1) наибольший общий делитель (p 41 0-1,p 42 0-1) должен быть небольшим;

   (2) канонические разложения чисел p 41 0-1 и p 42 0-1 должны иметь боль-
шие простые множители, которые обозначим p 41 0' и p 42 0';

   (3) числа p 41 0'-1 и p 42 0'-1 должны иметь большие простые множители;

   (4) числа p 41 0+1 и p 42 0+1 должны иметь большие простые множители;

   (5) числа   51 0/ 42 77 0(p 41 0-1) и  51 0/ 42 77 0(p 42 0-1) являются  _ 1безопасными числами . 0,
т.е.  являются простыми (из этого следует,  что числа p 41 0 и p 42 0 будут
различаться хотя бы на порядок).

 ш1.2
   Выбор безопасного числа в пакете символьных вычислений Maple ре-
ализован с помощью команды  2safeprime 0:
 ш1.0

   > safeprime(60871000);
                             60871367

 ш1.2
    3Замечание 0.
 ш1.1
   См. также [Утешев,Черкасов,Шапошников,2001,с.103,107,109].

 ш1.2
   Вопрос о  существенности применения именно сильных простых чисел
остаётся спорным. Эти свойства были предложены для того, чтобы зат-
руднить выполнение ряда алгоритмов факторизации. Однако самые быст-
рые алгоритмы одинаково "быстры" при факторизации любых чисел,  как
удовлетворяющих приведённым свойствам, так и нет.
   Далее, "длина" простых чисел гораздо важнее их структуры.
   Более того,  сама  структура уменьшает случайность числа и может
снизить надёжность криптосистемы.
   Но всё может измениться,  т.к. могут появиться новые методы раз-
ложения на множители, которые лучше работают с числами, обладающими
определёнными свойствами. В таком случае и могут понадобиться силь-
ные простые числа.

                           24. 0  3Протокол RSA

 ш1.0
                              1Я стащил у неё месяц тому назад связку
                              1ключей и,  таким образом, получил воз-
                              1можность  выходить на общий балкон,  а
                              1он тянется вокруг всего этажа,  и, та-
                              1ком образом, иногда навестить соседа. 0
                                      1М.Булгаков. Мастер и Маргарита
 ш1.2

   Пусть абоненты А и В решили наладить между собой секретную пере-
писку с открытым ключом.
   Вначале приведём   _ 1алгоритм 0  1построения ключей шифрования и дешиф-
 _ 1рования . 0.  _ 1Каждый . 0 (!) абонент ( 1независимо от другого 0):
 ш1.1
   (1) выбирает два больш 3и 0х простых числа;
   (2) вычисляет их произведение и значение функции Эйлера от этого
произведения;
   (3) выбирает случайное целое число,  меньшее вычисленного значе-
ния функции Эйлера и взаимно простое с ним;
   (4) конструирует новое целое число с помощью выбранного в п.(3).

 ш1.2
   Опишем действия абонента A:
 ш1.0

                                        ═о 5Выбирается A случайно
   A: p 41 0,p 42 0 => 1  0r 4A 0=p 41 77 0p 42 0 =>  7f 0(r 4A 0) => 0< 3a 0< 7f 0(r 4A 0), ( 3a 0, 7f 0(r 4A 0))=1.

 ш1.2
   Здесь обозначены:
 ш1.1
   - r 4A 0 - произведение двух  1простых 0 чисел, известных только A;
   -  3a 0 -  _ 1открытый ключ . 0, доступный каждому, кто хочет передать А сек-
ретное сообщение.

 ш1.2
   Далее, абонент A вычисляет свой  _ 1закрытый ключ . 0  7a 0 как решение сле-
дующего (разрешимого!) сравнения:
 ш1.0

    3a 77a= 01 (mod  7f 0(r 4A 0)) 1, 0 0< 7a 0< 7f 0(r 4A 0), ( 3a 0, 7f 0(r 4A 0))=1,

 ш1.2
   Действия абонента B аналогичны:
 ш1.0
                                        ═о 5Выбирается B случайно
   В: q 41 0,q 42 0 => 1  0r 4B 0=q 41 77 0q 42 0 =>  7f 0(r 4B 0) => 0< 3b 0< 7f 0(r 4B 0), ( 3b 0, 7f 0(r 4B 0))=1,

 ш1.2
   Здесь обозначены:
 ш1.1
   - r 4B 0 - произведение двух  1простых 0 чисел, известных только В;
   -  3b 0 -  _ 1открытый ключ . 0, доступный каждому, кто хочет передать В сек-
ретное сообщение.

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Для протокола RSA важно,  чтобы каждый абонент выбирал собствен-
ную пару простых чисел, т.е. (p 41 0,p 42 0) 7- 0(q 41 0,q 42 0), т.к. в противном слу-
чае один абонент мог бы читать зашифрованные сообщения,  предназна-
ченные для другого абонента.
   Однако этого не требуется для чисел 3 a 0 и  3b 0.

 ш1.2
   Далее, абонент B вычисляет свой  _ 1закрытый ключ . 0  7b 0 как решение сле-
дующего (разрешимого!) сравнения:
 ш1.0

    3b 77b= 01 (mod  7f 0(r 4B 0)) 1, 0 0< 7b 0< 7f 0(r 4B 0), ( 3b 0, 7f 0(r 4B 0))=1.

 ш1.2
   Итак, RSA-ключи построены и заполнена таблица:
 ш1.0

    4┌ 0───────╥────────┬──────── 4┐
    1│ 3Абонент 0║ 3Открытые 1│ 3Закрытые 1│
   │       ║  3ключи 0  │  3ключи 0  │
   ╞═══════╬════════╪════════╡
   │   A   ║  r 4A 1,  3a 0 │     7a 0   │
   │   B   ║  r 4B 1,  3b 0 │     7b 0   │
    4└ 0───────╨────────┴──────── 4┘

 ш1.2
   Часть этой таблицы (её можно назвать " 1телефонной книгой 0") публи-
куется и становится доступной для всех желающих общаться с A и B:
 ш1.0

   ┌──────────┐
   │ A: r 4A 0,  3a 0 │
   │ В: r 4B 0,  3b 0 │
   └──────────┘

 ш1.2
   Пусть абонент А решает послать абоненту B сообщение m, при этом
 ш1.0

   0<m<r 4B 0.

 ш1.2
   В противном  случае передаваемое сообщение разделяют на фрагмен-
ты, длины которых меньше r 4B 0.
   Абонент А  _ 1шифрует . 0 m открытым ключом абонента В, имеющемся  в те-
лефонной книге, для чего вычисляет значение
 ш1.0

   m 41 7= 0 m 5b 0 (mod r 4B 0) 1, 0 0<m 41 0<r 4B 0,

 ш1.2
и посылает его B.
   Абонент В  _ 1расшифровывает . 0 сообщение m 41 0 закрытым ключом  7b 0:
 ш1.0

   m 42 7= 0 m 41 7И 0 (mod r 4B 0) 1, 0 0<m 42 0<r 4B 0.

 ш1.2
    3Замечание 0 ( 1важное 0) [Ян,2011,с.75-76].
 ш1.1
   Для увеличения  скорости шифрования (и проверки электронной под-
писи) криптосистемы RSA для открытого ключа 3 e 0 часто выбирается  не-
большое значение, например: 3 e 0= 3,  3e 0= 17,  3e 0= 2 516 0+1= 65537. В отличие
от 3 e 0, закрытый ключ 3 d 0 всегда должен принимать большие значения, что
делает расшифровку и генерацию подписи медленными операциями.
   Однако существует способ увеличения скорости вычисления операций
возведения в степень,  связанных со значением 3 d 0,  основанный на ки-
тайской теореме об остатках. Опишем его.
   Для расшифрования RSA  _ 1авторизованный . 0 (!) пользователь знает зна-
чение закрытого  ключа   3d 0 и,  следовательно,  знает p и q,  поэтому
 _ 1вместо . 0 (!) непосредственного вычисления m 7= 0 C 5d 0 (mod N) можно  решить
следующие сравнения:
 ш1.0

   m 4p 7= 0 C 5d 7= 0 C 5d 0  5mod 0  5(p-1) 0 (mod p),
                                                               (*)
   m 4q 7= 0 C 5d 7= 0 C 5d 0  5mod 0  5(q-1) 0 (mod q),

после чего использовать  1китайскую теорему об остатках 0 и получить

       4┌ 0                                    4┐
   m 7= 0 │m 4p 77 0q 77 0(q 5-1 0 mod p) + m 4q 77 0p 77 0(p 5-1 0 mod q)│ (mod N).
       4└ 0                                    4┘

 ш1.2
   Докажем выполнимость сравнения (*):
 ш1.0

        k 77f 0(p)+ d mod  7f 0(p)
   C 5d 7= 0 C 5             0       (mod p) =>

             4┌ 0  7f 0(p) 4┐ 0k  d mod  7f 0(p)
     => C 5d 7= 0 │C 5     0│ 5  77 0C 5  0         (mod p) => { по теореме Эйлера } =>
             4└ 0      4┘
             d mod  7f 0(p)
     => C 5d 7= 0 C 5  0         (mod p).

 ш1.1
   Возведение в степень в совокупности с  использованием  китайской
теоремы об остатках работает в 4 раза быстрее,  чем простое модуль-
ное возведение в степень C 5d 0 mod N. Отметим, что вычисление
 ш1.0

   m 4p 7= 0 C 5d 0  5mod 0  5(p-1) 0 (mod p), m 4q 7= 0 C 5d 0  5mod 0  5(q-1) 0 (mod q)

 ш1.1
требует вдвое меньше операций умножения по сравнению с  вычислением
m 7= 0 C 5d 0 mod N.  Кроме того, все промежуточные значения при вычислении
m 4p 0 и m 4q 0 в два раза меньше промежуточных значений в процессе  вычис-
ления m 7= 0  C 5d 0  mod N,  потому что они лежат в интервале [1,p],  а не
[1,N]. Поэтому возведение в степень с использованием китайской тео-
ремы об остатках в  _ 1четыре раза . 0 быстрее,  чем обычное модульное воз-
ведение в степень.
   Далее заметим,  что  применение  китайской теоремы об остатках в
данном случае - палка о двух концах:
   (а) появляется отличная возможность  _ 1ускорить вычисления . 0 дешифро-
вания RSA,  что можно реализовать на достаточно дешёвом  оборудова-
нии;
   (б) становятся актуальными некоторые атаки,  связанные с  техни-
ческими каналами утечки информации.

 ш1.2
    2Теорема 0 ( 1важная 0).
 ш1.1
    2(1) 0 Протокол RSA шифрует и дешифрует сообщение m корректно, т.е.
справедливо равенство m 42 0=m.
    2(2) 0 Злоумышленник,  перехватывающий все сообщения и знающий  всю
открытую информацию (r 4A 0, r 4B 0,  3a 0,  3b 0, m 41 0), не сможет найти сообщение m
за заданное время.

 ш1.2
    2Доказательство 0.
    21. 0  _ 1Первый способ . 0. Пусть 0<m 41 0<r 4B 0, 0<m 42 0<r 4B 0. Тогда:
 ш1.0

   m 41 7= 0m 5b 0 (mod r 4B 0) => m 42 7= 0m 41 7И 0 (mod r 4B 0) => m 42 7= 0m 5b 7И 0 (mod r 4B 0).

   Теперь воспользуемся следующим утверждением:

    3b 77b= 01 (mod  7f 0(r 4B 0)) =>  3b 77b 0= 1 + t 77 0mod  7f 0(r 4B 0),

 ш1.2
а также тем,  что если p и q - простые числа,  p 7- 0q, k - любое целое
число, то
 ш1.0

       k 7f 0(p 77 0q)+1
   a 7= 0 a         (mod (p 77 0q)),

и получим:
                            1+t 77 0mod  7f 0(r 4B 0)
   m 42 7= 0 m 5b 7И 0 (mod r 4B 0) => m 42 7= 0 m            (mod r 4B 0) => m 42 0=m.

 ш1.2
    22. 0  _ 1Второй способ . 0.  Предположим,  что читающий является  знатоком
 1индексов 0:
 ш1.0

   m 41 7= 0m 5b 0 (mod r 4B 0) => m 41 7И= 0m 5b 7И 0 (mod r 4B 0).

   m 42 7= 0m 41 7И 0 (mod r 4B 0), m 41 7И= 0m 5b 7И 0 (mod r 4B 0) => m 42 7= 0m 5b 7И 0 (mod r 4B 0) =>

     => 1 ind 4g 0m 42 7= 0b 7b7 1ind 4g 0m (mod  7f 0(r 4B 0)) =>  1ind 4g 0m 42 7= 1ind 4g 0m (mod  7f 0(r 4B 0)) =>

     => m 42 7= 0m (mod r 4B 0), 0<m<r 4B 0, 0<m 42 0<r 4B 0 => m 42 1= 0m.

 ш1.2
    22. 0 Злоумышленник знает r 4A 0, r 4B 0,  3a 0,  3b 0, m 41 0.
   Для вычисления m 42 0 необходимо определить закрытый ключ 7 b 0, для че-
го требуется знать  7f 0(r 4B 0)= (q 41 0-1) 77 0(q 42 0-1), т.е. знать q 41 0 и q 42 0.
   Итак, злоумышленник сталкивается с  задачей  факторизации  числа
r 4B 0, которая при достаточно большом r 4B 0 является неразрешимой в тече-
ние заданного времени.
    1Теорема доказана 0.
    3Замечание 0 ( 1важное 0) [Шнайер,2002,с.525-526].
 ш1.1
   Утверждение, что безопасность RSA зависит от проблемы разложения
на множители больших чисел,  является  _ 1гипотетическим . 0,  т.к. никто и
никогда не доказал математически,  что для восстановления m по r 4B 0 и
m 41 0 нужно разложить r 4B 0 на множители.
   Понятно, что может быть открыт совсем иной способ  криптоанализа
RSA.  Но  если  этот новый способ позволит криптоаналитику получить
закрытый ключ 7 b 0,  то он также может быть использован для разложения
на множители больших чисел.

 ш1.2
                  3Работа с примерами решённых задач
 ш1.1
   См. Пример 2, Пример 5.

 ш1.2
                     24 41 2. 0  3Протокол RSA с цифровой
                              3подписью
   Рассмотренный выше протокол RSA невскрываем  при  больших  r 4A 0  и
r 4B 0, но обладает следующим недостатком: A передаёт информацию B, ис-
пользуя открытую информацию абонента B (числа r 4B 0 и  3b 0).
   Злоумышленник не может читать сообщения,  предназначенные для B,
однако он может  _ 1передать сообщение к . 0  1B 0  _ 1от имени . 0  1A 0.
   Избежим этого, используя  следующий протокол  (по [Рябко,Фионов,
2018,с.36].
   Абонент A хочет передать B сообщение m.
   Вначале A вычисляет числа
 ш1.0

   m 41 0= m 7Ф 0  1mod 0 r 4A 0, m 42 0= m 41 5b 0  1mod 0 r 4B

 ш1.2
и пересылает m 42 0 абоненту B.
   Заметим, что  злоумышленник не может выполнить подобные вычисле-
ния (он не знает 7  0закрытого ключа  7a 0), а поэтому не может послать со-
общение от имени A.
   Абонент B получает m 42 0 и последовательно вычисляет
 ш1.0

   m 43 0= m 42 7И 0  1mod 0 r 4B 0, m 44 0= m 43 5a 0  1mod 0 r 4A 0.

 ш1.2
   В результате абонент B получает сообщение m 44 0=m.
   Заметим, что  злоумышленник не может выполнить подобные вычисле-
ния (он не знает 7  0закрытого ключа  7a 0), а  поэтому не  может  прочесть
сообщение m 44 0.
    2Теорема 0.
 ш1.0

   m 44 0= m.

 ш1.2
    2Доказательство 0. Воспользуемся способом построения закрытых  клю-
чей 7 a 0 и  7b 0, а также теоремой Эйлера:
 ш1.0

    3a 77a= 01 (mod  7f 0(r 4A 0)) 1, 0 0< 7a 0< 7f 0(r 4A 0), ( 3a 0, 7f 0(r 4A 0))=1,
    3b 77b= 01 (mod  7f 0(r 4B 0)) 1, 0 0< 7b 0< 7f 0(r 4B 0), ( 3b 0, 7f 0(r 4B 0))=1 =>

   =>  3a 77a 0= 1+ k 41 77f 0(r 4A 0),  3b 77b 0= 1+ k 42 77f 0(r 4B 0) =>

   =>  3a 77a 3b 77b 0= (1+k 41 77f 0(r 4A 0)) 77 0(1+ k 42 77f 0(r 4B 0))=
            = 1 + k 41 77f 0(r 4A 0) + k 42 77f 0(r 4B 0) + k 41 77 0k 42 77f 0(r 4A 0) 7f 0(r 4B 0) =>

   => m 44 0= m 43 5a 0  1mod 0 r 4A 0= (m 42 7И 0  1mod 0 r 4B 0) 5a 0  1mod 0 r 4A 0= m 42 7И 5a 0  1mod 0 r 4B 0  1mod 0 r 4A 0=

        = m 7ФИ 5ab 0  1mod 0 r 4B 0  1mod 0 r 4A 0= m 5(a 7Ф 5)(b 7И 5) 0  1mod 0 r 4B 0  1mod 0 r 4A 0=

           1 + k 41 77f 0(r 4A 0) + k 42 77f 0(r 4B 0) + k 41 77 0k 42 77f 0(r 4A 0) 7f 0(r 4B 0)
        = m                                           1mod 0 r 4B 0  1mod 0 r 4A 0=

             4┌ 0  7f 0(r 4A 0) 4┐ 0k 41 0  4┌ 0  7f 0(r 4B 0) 4┐ 0k 42 0  4┌ 0  7f 0(r 4A 0) 4┐ 7f 0(r 4B 0) 77 0k 41 0k 42
        = m 772 0m      72 0   772 0m      72  72 0m      72 0           1mod 0 r 4B 0  1mod 0 r 4A 0=m.
             4└ 0       4┘ 0    4└ 0       4┘ 0    4└ 0       4┘

 ш1.2
    1Теорема доказана 0.
   Итак, B знает,  что сообщение пришло именно от A, т.е. абонент A
как бы "подписал" его, зашифровав своим закрытым ключом 7 a 0.
   Фактически этот протокол является примером подключения  к  алго-
ритму RSA  _ 1электронной . 0 ( _ 1цифровой . 0)  _ 1подписи . 0, которая является одним из
широко используемых на практике изобретений криптографии.
                    25. 0  3Протокол RSA 0  3без передачи
                               3ключей
   Пусть абоненты А и В условились организовать секретную переписку
между собой, для чего  _ 1они выбирают . 0 достаточно большое простое число
р,  такое,  что р-1 хорошо разлагается на не очень большие  простые
множители.
   Абоненты А и В независимо один от другого выбирают соответствен-
но  1случайные 0 натуральные числа  3а 0 и  3Ь 0 взаимно простые с числом  р-1,
т.е. (a,p-1)=1, (b,p-1)=1.
   Числа  3a 0 и  3b 0 называются  _ 1первыми закрытыми ключами абонентов . 0  1A  _и . B
соответственно.
   Далее, абонент А находит число  7a 0, решая  1сравнение
 ш1.0

    3a 77a= 01 (mod  7f 0(р)), 0< 7a 0<р-1.                                   (1)
                                        7f 0( 7f 0(р))-1
например, с помощью теоремы Эйлера:  7a 0= 3a 0          1mod 0  7f 0(р).

 ш1.2
   Ключ 7 a 0 называется  _ 1вторым закрытым ключом абонента . 0  1A 0.
   Теперь A обладает двумя закрытыми ключами  7a 0 и  3а 0.
   Абонент В находит число  7b 0, решая  1сравнение
 ш1.0

    3b 77b= 01 (mod  7f 0(р)), 0< 7b 0<р-1,                                   (2)

например, с помощью теоремы Эйлера:

        7f 0( 7f 0(р))-1
    7b 0= b          1mod 0  7f 0(р).

 ш1.2
   Ключ 7 b 0 называется  _ 1вторым закрытым ключом абонента . 0  1B 0.
   Теперь B обладает двумя закрытыми ключами  7b 0 и  3Ь 0.
   Пусть абонент А решает послать абоненту В сообщение
 ш1.0

   m 7е ═N 0, 0<m<р-1.

 ш1.2
   Абонент A  вначале зашифровывает это сообщение  _ 1своим первым зак-
 _ 1рытым ключом . 0, для чего он вычисляет
 ш1.0

   m 41 7= 0 m 5a 0 (mod р), 0<m 41 0<р,       1     0                            (3)

 ш1.2
и отправляет результат абоненту В.
   Абонент В, в  свою очередь, зашифровывает  полученное  сообщение
 _ 1своим первым закрытым ключом
 ш1.0

   m 42 7= 0 m 41 5b 0 (mod р), 0<m 42 0<р,                                1     0  (4)

 ш1.2
и пересылает его обратно абоненту А.
   Абонент А, получив обратно  уже  дважды зашифрованное сообщение,
шифрует его в третий раз  _ 1своим вторым закрытым ключом . 0:
 ш1.0

   m 43 7= 0 m 42 7Ф 0 (mod р), 0<m 43 0<р,                                1     0  (5)

 ш1.2
и вновь отправляет его абоненту В.
   Абонент B зашифровывает этот шифротекст при помощи  _ 1своего второ-
 _ 1го закрытого ключа . 0:
 ш1.0

   m 44 7= 0 m 43 7И 0 (mod р), 0<m 44 0<р.

 ш1.2
    2Теорема 0 (по [Нечаев,1999,с.27]).
 ш1.0

   m 44 1= 0 m 1.

 ш1.2
    2Доказательство 0. Вначале, перемножив сравнения (1) и (2), получим
 ш1.0

    3ab 77ab= 01 (mod  7f 0(р)).

 ш1.2
   Возведём обе части сравнения (3) в степень b
 ш1.0

   m 41 7= 0 m 5a 0 (mod р) => m 41 5b 7= 0 m 5ab 0 (mod р).

 ш1.2
   Воспользуемся сравнением (4) и транзитивностью сравнений:
 ш1.0

   m 41 5b 7= 0 m 5ab 0 (mod р), m 42 7= 0 m 41 5b 0 (mod р) => m 42 7= 0 m 5ab 0 (mod р).

 ш1.2
   Возведём обе части сравнения (5) в 3  0 степень 7 a 0, воспользуемся да-
лее сравнением (5) и транзитивностью сравнений:
 ш1.0

   m 42 7Ф= 0 m 5ab 7Ф 0 (mod р), m 43 7= 0 m 42 7Ф 0 (mod р) => m 43 7= 0 m 5ab 7Ф 0 (mod р).

 ш1.2
   Далее, знатоки индексов (?!) легко получат:
 ш1.0

   m 43 7И= 0 m 5ab 7ФИ 0 (mod р), m 44 7= 0 m 43 7И 0 (mod р) => m 44 7= 0 m 5ab 7ФИ 0 (mod р) =>

      =>  1ind 4g 0m 44 7= 0  3a 7a7 3b 7b7 1ind 4g 0m (mod  7f 0(р)) =>

      =>  1ind 4g 0m 44 7= 0 1 77 01 77 1ind 4g 0m (mod  7f 0(р)) => m 44 7= 0m (mod р),

 ш1.2
а т.к. числа m 44 0 и m положительны и меньше р, то m 44 1= 0m 1.
    1Теорема доказана 0.
                  3Работа с примерами решённых задач
   См. Пример 3, Пример 6.

                     26. 0  3Алгоритмические аспекты
                      3организации алгоритма RSA

 ш1.0
            1- Не уверяйте меня, будто гоблины не умеют считать. Уме-
            1ют. Двенадцать не пятнадцать, и они это отлично знают. 0
            1- Я тоже. Там ещё были Бифур и Бофур.
                              1Дж. Толкин. Хоббит, или Туда и Обратно
 ш1.2

   Ответим на несколько вопросов, относящихся к организации RSA (по
[Кормен,2014,с.149-153]):
 ш1.1
   - как работать с числами, состоящими из сотен десятичных цифр?
   - как найти большие простые числа за разумное время?
   - как найти 3 e 0, взаимно простое с  7f 0(m)?
   - как вычислить 3 d 0, мультипликативно обратное 3 e 0 по модулю  7f 0(m)?

 ш1.2
   Отметим, что ранее мы уже ответили на следующие вопросы:
 ш1.1
   (1) как за разумное время вычислить x 5d 1 mod 0 n, если 3 d 0 велико?
   (1) как убедиться в том, что если c 7= 0x 5e 0 (mod m), то x 7= 0c 5d 0 (mod m)?.

 ш1.2
    21. 0  _ 1Арифметика больших чисел . 0.
   Очевидно, что большие числа, которые требуются в реализации RSA,
не  могут поместиться в регистрах большинства компьютеров (типичный
размер которых - 64 бита).
   Тем не менее, несколько математических пакетов (например, Maple)
и некоторые языки программирования (Haskell,  Python) позволяют ра-
ботать с целыми числами, которые "не имеют" фиксированного предель-
ного размера.
    2Пример 0.
 ш1.1
   Сравним время вычисления степеней в языках программирования:
   (1) в языке Python вычисления продолжались  7~ 016 мин:
 ш1.0

   >>> 2**10000000
   ...55732662370891387109376L

 ш1.1
   (2) в языке Haskell вычисления продолжались 33.69 сек (вместе  с
выводом всех десятичных цифр) и 8.41 сек (без вывода):
 ш1.0

   Prelude> 2^10000000        ║ Prelude> length $ show $ 2^10000000
   ...55732662370891387109376 ║ 3010300

 ш1.1
   Далее, выведем все десятичные цифры числа 2 51023 0, а также устано-
вим, что число содержит  _308 цифр . в  десятичном  разложении  и   _1024
 _цифры . в двоичном:
 ш1.0

   Prelude> 2^1023
   8988465674311579538646525953945123668089884894711532863671504057
   8866337902750481566354238661203768010560056939935696678829394884
   4072083112464237153197370621888839467124327426381511098006230470
   5972654147604250288441907534117123144073695655527041361858167525
   5342293149119973622969239858152417678164812112068608

   Prelude> length $ show $ 2^1023
   308
   Prelude> 1 + (truncate $ logBase 2 (2^1023))
   1024

 ш1.2
   Кроме того, арифметика в RSA является  _ 1модульной арифметикой . 0, ко-
торая позволяет нам ограничить размеры целых чисел,  с которыми нам
приходится работать.
   Например, при вычислении (x 5d 1 mod 0 n) мы  вычисляем  промежуточные
результаты,  представляющие собой значение x,  возведённое в разные
степени, но по модулю n, что означает, что они находятся в диапазо-
не от 0 до n-1.
    3Замечания 0.
 ш1.1
    21. 0 Если зафиксировать максимальные размеры p и q, то этим фикси-
руется и максимальный размер n,  что, в свою очередь, означает, что
возможна аппаратная реализация алгоритма RSA.
    22. 0 (По [Введение,2012,с.94])  Созданы  и получили  широкое  рас-
пространение  специальные   _ 1языки программирования . 0,  предназначенные
для вычислений с большими числами (например,  PARI и UBASIC,  расп-
ространяемые свободно).

 ш1.0
                                          1Простота доведёт до поста.
                                                           1Пословица
 ш1.2

    22. 0  _ 1Поиск больших простых чисел . 0.
   Найти большое простое число можно путём неоднократной произволь-
ной генерации большого нечётного числа  с  последующим  применением
 _ 1теста простоты Миллера-Рабина . 0 для выяснения,  является ли это число
простым, т.е. "натолкнуться" на простое число.
   Можно решить,  что таким образом придётся искать большое простое
число слишком долго.  Вдруг простые числа с  их  ростом  становятся
крайне редки?  Тогда придётся потратить огромное количество времени
на поиск простой иголки в "составном стоге сена".
   Однако теорема Чебышёва о распределении простых чисел  показыва-
ет,  что   _ 1количество . 0 натуральных простых чисел,  меньших некоторого
натурального m, асимптотически близка к m/( 1ln 0(m)), а тогда  _ 1доля . 0 на-
туральных   простых   чисел,   меньших  натурального  m,  близка  к
1/( 1ln 0(m)).
    2Пример 0.
 ш1.1
   Количество простых чисел в (2,10 5100 0) оценивается как  7~ 04.34 77 010 597 0,
а доля простых чисел, меньших 10 5100 0, близка к
 ш1.0

       1           1
   ───────── = ──────────  7~ 0  51 0/ 4230 0.
    1ln 0(10 5100 0)   100 77 1ln 0(10)

 ш1.2
   Легко получить, что 90% этих чисел находятся в (10 590 0,10 5100 0):
 ш1.0

      10 590-100 77 1ln 0(10 5100 0)        100
   1- ────────────────── = 1- ───────  7~ 0 0.99999999988...
            1ln 0(10 590 0)           90 77 010 510

 ш1.2
   Поэтому доля простых чисел в (10 590 0,10 5100 0) также составляет около
 51 0/ 4230 0, и если наугад выбрать число, содержащее  7~ 0333 бита, т.е. при-
надлежащее (10 590, 010 5100) 0, то с вероятностью  51 0/ 4230 5  0оно окажется прос-
тым.

 ш1.2
   Итак, если  мы  выберем  случайное  большое натуральное нечётное
число x и будем проверять на простоту последовательно числа x, x+1,
x+2,..., то  в  среднем  простое число встретится на шаге с номером
 1ln 0(x), т.е. достаточно быстро.
   Другими словами,  в среднем придётся испытать только около  1ln 0(m)
чисел "недалеко" от m, прежде чем найдётся простое число.
   Так, если будем искать простое число, содержащее 1024 бита, то
 ш1.0

    1ln 0(2 51024 0)= 1024 77 1ln 0(2) 7~ 0 710,

 ш1.2
и компьютер  очень быстро может выполнить тест простоты Рабина-Мил-
лера для 710 чисел.
   На практике можно использовать ещё более простой тест.
   Вспомним, что  _ 1малая теорема Ферма . 0 утверждает, что если m являет-
ся простым числом, то x 5m-1 1 mod 0 m=1 для любого x 7е 0[1,m-1].
   Но обратное утверждение ( 1если 0 x 5m-1 1 mod 0 m=1  1для любого 0 x 7е 0[1,m-1],
 1то 0 m  1является простым числом 0) не справедливо,  но среди больших чи-
сел исключения очень редки.  Фактически этого  _ 1почти всегда . 0 (!) дос-
таточно, чтобы  просто проверять нечётные целые числа m и объявлять
m простым, если 2 5m-1 1 mod 0 m=1.
   Кстати, вспомним, что 2 5m-1 1 mod 0 m можно вычислить с помощью всего
лишь 7 Q 0( 1log 42 0m) умножений.
    2Пример 0.
 ш1.1
   Следующий код позволяет породить последовательность нечётных чи-
сел, подавляющая часть которых являются простыми:
 ш1.0

   filter (\x -> 2^(m-1) `mod` m == 1) [3,5..]
                                                      
 ш1.1
   Однако приходится быть осторожным.
   В самом деле,  нетрудно получить и исследовать следующий список,
полученный для натуральных чисел из [1,100000] за 1399.03 сек:
 ш1.0

   [( 341,2),( 561,3),( 645,3),(1105,3),(1387,2),(1729,3),(1905,3),
    (2047,2),(2465,3),(2701,2),(2821,3),(3277,2),(4033,2),(4369,2),
    (4371,3),(4681,2),(5461,2),(6601,3),(7957,2),(8321,2),(8481,3),
    (8911,3),(10261,2),(10585,3),(11305,4),(12801,3),(13741,3),
    (13747,2),(13981,3),(14491,2),(15709,2),(15841,3),(16705,3),
    (18705,4),(18721,2),(19951,2),(23001,4),(23377,2),(25761,3),
    (29341,3),(30121,3),(30889,3),(31417,2),(31609,2),(31621,2),
    (33153,3),(34945,3),(35333,2),(39865,4),(41041,4),(41665,3),
    (42799,2),(46657,3),(49141,2),(49981,2),(52633,3),(55245,4),
    (57421,3),(60701,2),(60787,2),(62745,4),(63973,4),(65077,2),
    (65281,2),(68101,3),(72885,4),(74665,3),(75361,4),(80581,2),
    (83333,2),(83665,3),(85489,2),(87249,3),(88357,2),(88561,3),
    (90751,2),(91001,3),(93961,3)]

 ш1.1
   Первый компонент каждой пары является числом, "подозрительным на
простое" и полученным с помощью малой теоремы Ферма.
   Второй компонент каждой пары - это количество простых множителей
в факторизации первого компонента пары.
   Таким образом,  малая  теорема Ферма может быть использована для
нахождения простых чисел, но требуется дополнительная проверка.

 ш1.2
   Наконец, для генерации больших простых  чисел  можно  воспользо-
ваться средствами языков программирования.
   Например, генерация случайного  _ 1простого числа . 0,  представимое за-
данным количеством   _ 1битов . 0 (!) в языке программирования Scala выпол-
няется так:
 ш1.0

   scala> BigInt.probablePrime(350,scala.util.Random)
   res16: scala.math.BigInt 
   = 12201430188195486952156653406624066311215619434676249593563436
     47823980862852576491528926163541609881243951 (106 цифр)

   scala> BigInt.probablePrime(1024,scala.util.Random)
   res15: scala.math.BigInt 
   = 11133780670709530579568335363468440732154998309694826786990558
     61494875917448962569351811310682172045430355226824423840636417
     97574142496758779822566719447570182884481125320702445820446210
     87551227175668515069471352820533357029683826620879234904645522
     1949053899614333144504758445623338991681776480517401176149859
     (309 цифр)

 ш1.2
    23. 0  _ 1Как найти . e,  _взаимно простое с .  7f 0(m).
   Нам нужно найти небольшое нечётное целое число 3 e 0,  взаимно прос-
тое с числом  7f 0(m).  Будем использовать алгоритм для вычисления наи-
большего общего делителя двух целых чисел (НОД, gcd).
   Таким образом,  если  есть значение-кандидат для 3 e 0,  то вызываем
функцию Euclid( 3e 0, 7f 0(m)),  и если значением функции  является  1,  то
проверяемое значение-кандидат для 3 e 0 является взаимно простым с  7f 0(m).
   Если это не так,  то следует испытать  другое  значение-кандидат
для 3 e 0, пока не найдётся взаимно простое с  7f 0(m).
   Сколько в среднем кандидатов придётся перепробовать? Немного.
   Если ограничиться выбором для 3 e 0 нечётных простых чисел, меньших,
чем  7f 0(m), то весьма вероятно, что любой выбор будет взаимно простым
с   7f 0(m).  Это связано с тем,  что согласно теореме о простых числах
имеется около  7f 0(m)/ 1ln 0( 7f 0(m)) простых чисел, меньших  7f 0(m), но ещё од-
на теорема показывает,  что  7f 0(m) не может иметь более чем  1log 410 7f 0(m)
простых множителей.
   Поэтому мы вряд ли столкнёмся с простым сомножителем  7f 0(m).

    24. 0  _ 1Как вычислить . 3 d 0,  _ 1мультипликативно обратное . 3 e 0  _ 1по модулю . 0  7f 0(m).
   После того  как получены 3  7f 0(m) и  3e 0,  необходимо вычислить 3 d 0 - об-
ратное к 3 e 0 по модулю  7f 0(m), такое, что
 ш1.0

    3e 77 3d 7= 0 1 ( 1mod 0  7f 0(m)).

 ш1.2
    _ 1Второй способ . 0 состоит в решении сравнения
 ш1.0

    3e 77 3d 7= 0 1 ( 1mod 0  1lcm 0(p-1,q-1)),              ║ 1 gcd 0(x,y) 77 1lcm 0(x,y)= x 77 0y

 ш1.2
где 1 lcm 0(x,y) - наименьшее общее кратное x и y.
    _ 1Третий способ . 0. Вспомним, что  _ 1обобщённый алгоритм Евклида . 0 основан
на теореме из теории чисел,  которая гласит, что если a и b - целые
числа,  одновременно не равные 0, то НОД(a,b)=a 77 0i+b 77 0j для некоторых
целых i и j. Поэтому обобщённый алгоритм возвращает тройку
 ш1.0

   (НОД(a,b), i, j).

 ш1.2
   Теперь обобщённый алгоритм, применённый к 3 e 0 и  7f 0(m) вернёт тройку
(1,i,j), причём
 ш1.0

    7f 0(m) 77 0i +  3e 77 0j= 1.

 ш1.2
   Поэтому можно просто положить 3 d 0= j 1 mod 0  7f 0(m).
   В самом деле, вспомним, что  3e 0< 7f 0(m) и выполним вычисления:
 ш1.0

   1=  7f 0(m) 77 0i +  3e 77 0j =>
     => 1  1mod 0  7f 0(m)= ( 7f 0(m) 77 0i +  3e 77 0j)  1mod 0  7f 0(m)=
                  = ( 7f 0(m) 77 0i)  1mod 0  7f 0(m) + ( 3e 77 0j)  1mod 0  7f 0(m)=
                  = ( 3e 77 0j)  1mod 0  7f 0(m)= ( 3e 0  1mod 0  7f 0(m)) 77 0(j  1mod 0  7f 0(m))=
                  =  3e 77 0(j  1mod 0  7f 0(m))
     =>  3d 0= j 1 mod 0  7f 0(m).

 ш1.2
   Однако j может быть отрицательным.
   Одним из способом интерпретации значения j  1mod 0  7f 0(m) при  отрица-
тельном  j  - это начать с j и прибавлять  7f 0(m) до тех пор,  пока не
получится неотрицательное число, которое и будет равно j 1 mod 0  7f 0(m).
   Например, чтобы  найти  (-27) 1 mod 0 10, получается  последователь-
ность -27, -17, -7, 3.  Получив последнее значение, мы останавлива-
ется и утверждаем, что (-27) 1 mod 0 10=3.
                      27. 0  3Стандартная оцифровка
                              3алфавитов
   В криптографии, как правило, работают с  _ 1оцифрованными текстами . 0.
   Единицы текста заменяют на числа разной природы,  которыми могут
быть обычные целые числа, элементы колец вычетов, конечных полей.
   Оцифровка не является шифрованием. Исходный текст в его записи в
данном алфавите должен легко и однозначно восстанавливаться по сво-
ему оцифрованному виду.
   Приведём вариант  _ 1оцифровки русского алфавита . 0:
 ш1.0

    1Пробел 0  а  б  в  г  д  е  ё  ж  з  и  й  к  л  м  н  о  п  р
     00    01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18

           с  т  у  ф  х  ц  ч  ш  щ  ъ  ы  ь  э  ю  я
           19 20 21 22 23 24 25 26 27 28 29 30 31 32 33

 ш1.2
   Текст "я студент университета" оцифровывается так:
 ш1.0

   33 _00 .19202105061520 _00 .211510030618191020062001.

 ш1.2
   Оцифровка 15131811 восстанавливается как "омск".
   Приведём также вариант  _ 1оцифровки английского алфавита . 0:
 ш1.0

    1Пробел 0  a  b  c  d  e  f  g  h  i  j  k  l  m
     00    01 02 03 04 05 06 07 08 09 10 11 12 13

           n  o  p  q  r  s  t  u  v  w  x  y  z
           14 15 16 17 18 19 20 21 22 23 24 25 26

 ш1.2
   Текст "i am a student" оцифровывается так:
 ш1.0

   09 _00 .0113 _00 .01 _00 .19202104051420.

 ш1.2
   Отсутствие в выбранном алфавите заглавных букв вынуждает нас пи-
сать тексты слитно, употребляя только строчные буквы.
   Если же предполагается использовать как строчные, так и  пропис-
ные буквы, то это должно быть зафиксировано в оцифровке.
   Другими словами,  _ 1всё зависит от выбранного алфавита . 0.

                           3Протокол Рабина

 ш1.0
               1Нашему естественному  сыновнему  уважению  к прошлому
               1велено обратиться в умиленное обожание. А это вредно.
                                                        1М.Л.Гаспаров
 ш1.2

   Вначале выбираются два случайных простых числа
 ш1.0

   p 7= 03 (mod 4), q 7= 03 (mod 4).

 ш1.2
   Произведение n=p 77 0q является  _ 1открытым . 0 ключом, а p и q -  _ 1закрытыми
ключами.
   Алиса для шифрования сообщения m (m<n) вычисляет:
 ш1.0

   C= m 52 0 mod n

и посылают результат Бобу, который вычисляет:

   a 41 0= C 5(p+1)/4 0 mod p,        b 41 0= C 5(q+1)/4 0 mod q,
        4┌ 0             4┐ 0              4┌ 0             4┐
   a 42 0= │p - C 5(p+1)/4 0│ mod p,  b 42 0= │q - C 5(q+1)/4 0│ mod q.
        4└ 0             4┘ 0              4└ 0             4┘

   Остаётся четыре раза применить  1китайскую теорему об остатках 0:

   p 41 0= 1 Chine 0([a 41 0,b 41 0],[p,q]),  p 43 0= 1 Chine 0([a 42 0,b 41 0],[p,q]),

   p 42 0= 1 Chine 0([a 41 0,b 42 0],[p,q]),  p 44 0= 1 Chine 0([a 42 0,b 42 0],[p,q]).

 ш1.2
   Один из четырёх результатов p 41 0, p 42 0, p 43 0, p 44 0 равен m.
   Если сообщение написано на естественном языке, выбрать правильно
p 4i 0 нетрудно. С другой стороны, если сообщение является потоком слу-
чайных битов (предназначенных,  например,  для генерации ключей или
цифровой подписи),  то  способа определить,  какое p 4i 0 является пра-
вильным, не существует.
   Одним из  способов решить эту проблему служит добавление к сооб-
щению заголовка, выполняемое перед шифрованием; данная операция на-
зывается  _ 1солтингом . 0  (англ.   1solting 0  - заполненное болото,  которое
иногда используется для выпаса скота).
    3Замечание 0 ( 1важное 0).
 ш1.1
   Безопасность схемы Рабина опирается на сложность поиска квадрат-
ных корней по модулю составного числа (эта проблема аналогична раз-
ложению на множители).

 ш1.2
    2Пример 1 0 ( 1выполнения протокола Рабина 0).
 ш1.1
   Пусть p=23, q=7 => n=p 77 0q= 161 (n - открытый ключ, p и q - закры-
тые ключи). Алиса хочет передать Бобу открытый текст m= 224 0; для это-
го она вычисляет:
 ш1.0

   C= 24 52 0 mod 161= 93.

   Боб получает C и вычисляет:

   a 41 0= 93 5(23+1)/4 0 mod 23= 1,   b 41 0= 93 5(7+1)/4 0 mod 7= 4,

   a 42 0=-93 5(23+1)/4 0 mod 23= 22,  b 42 0=-93 5(7+1)/4 0 mod 7= 3,

а затем четыре раза пользуется  1китайской теоремой об остатках 0:

   p 41 0= 1 Chine 0([1,4],[23,7])= 116,  p 43 0= 1 Chine 0([22,4],[23,7])= 137,

   p 42 0= 1 Chine 0([1,3],[23,7])=   224 0,  p 44 0= 1 Chine 0([22,3],[23,7])= 45.

   Остаётся выбрать нужное значение из четырёх.

 ш1.2
    2Пример 2 0 ( 1выполнения протокола Рабина 0).
 ш1.1
   Пусть p=7,  q=11 => n=p 77 0q= 77 (n - открытый ключ, p и q - закры-
тые ключи). Алиса хочет передать Бобу открытый текст m= 220 0; для это-
го она вычисляет:
 ш1.0

   C= 20 52 0 mod 77= 15.

 ш1.1
   Боб получает C и вычисляет:
 ш1.0

   a 41 0= 15 5(7+1)/4 0 mod 7= 1,   b 41 0= 15 5(11+1)/4 0 mod 11= 9,

   a 42 0=-15 5(23+1)/4 0 mod 7= 6,  b 42 0=-15 5(11+1)/4 0 mod 11= 2,

а затем четыре раза пользуется  1китайской теоремой об остатках 0:

   p 41 0= 1 Chine 0([1,9],[7,11])= 64,  p 43 0= 1 Chine 0([6,9],[7,11])=  220 0,

   p 42 0= 1 Chine 0([1,2],[7,11])= 57,  p 44 0= 1 Chine 0([6,2],[7,11])= 13.

   Бобу остаётся выбрать нужное значение из четырёх.

 ш1.2
    3Замечание 0.
 ш1.1
   Решение следующего квадратичного сравнения:
 ш1.0

   x 52 7= 0y (mod p),

 ш1.1
где p - нечётное простое число, сводится к выделению следующих слу-
чаев:
 ш1.0

   (1) если p 7= 03 (mod 4), то x 7= 0y 5(p+1)/4 0 (mod p);

   (2) если p 7= 05 (mod 8) и y 5(p+1)/4 0=1, то x 7= 0  7+ 0y 5(p+1)/8 0 (mod p);

   (3) если p 7= 05 (mod 8) и y 5(p+1)/4 7- 01, то x 7= 0  7+ 02y 77 0(4y) 5(p-5)/8 0 (mod p).

   (4) если p 7= 01 (mod 8),  то формулы,  описывающей решение,  не су-
ществует.
 ш1.2

                     3Использование пакета Maple

 ш1.0
             1Мальчик, дальше 0! 1 Здесь не встретишь ни веселья,
                                                 1ни сокровищ 0!
             1Но я вижу - ты смеешься, эти взоры - два луча.
             1На, владей волшебной скрипкой, посмотри в глаза чудовищ
             1И погибни славной смертью, страшной смертью скрипача 0!
                                 1Н.Гумилёв. Волшебная скрипка  0( 11908 0)
 ш1.2

   Для решения упражнений удобно пользоваться  1пакетом аналитических
 1вычислений 0  1Maple 0 как  _ 1оракулом . 0.
   Приведём сводку полезных функций этого пакета.
   Часть из них подгружается вызовом библиотеки
 ш1.0

   > with(numtheory);

 ш1.2
    _ 1Основные теоретико-числовые функции . 0:
 ш1.1
   (1) phi    - вычисление значения функции Эйлера  7f 0(n);
   (2) invphi - вычисление значений  7f 5-1 0(n);
   (3) safeprime - вычисление  1безопасного простого числа 0, ближайше-
го сверху к заданному натуральному числу;
   (4) primroot - вычисление первообразного корня по модулю;
   (5) ...      - порядок (показатель) числа по модуля;
   (6) issqrfree - предикат,  устанавливающий, свободно ли заданное
число от квадратов;
   (7) pi - вычисление значения функции 7  p 0(n),  определяющей  коли-
чество простых чисел, меньших натурального числа n;
   (8) floor - нахождение целой части числа;
   (9) isqrt - вычисление целой части квадратного корня из числа;
   (10) fermat   - нахождение чисел Ферма;
   (11) mersenne - нахождение чисел Мерсенна.

 ш1.2
    3Замечание 0.
 ш1.1
    _ 1Безопасным простым числом . 0 называется простое число p, для  кото-
рого простым является (p-1)/2.

 ш1.2
   Приведём листинг действий пользователя (вводимые команды начина-
ются после знака >) и реакции на них программы:
 ш1.0

   > # Выбор библиотеки для работы с функциями теории чисел с
   > # перечислением имён функций пакета
   > # ---------------------------------
   > with(numtheory);
     [GIgcd, bigomega, cfrac, cfracpol, cyclotomic, divisors,
      factorEQ, factorset, fermat, imagunit, index, integral_basis,
      invcfrac, invphi, issqrfree, jacobi, kronecker, lambda,
      legendre, mcombine, mersenne, migcdex, minkowski, mipolys,
      mlog, mobius, mroot, msqrt, nearestp, nthconver, nthdenom,
      nthnumer, nthpow, order, pdexpand, phi, pi, pprimroot,
      primroot, quadres, rootsunity, safeprime, sigma, sq2factor,
      sum2sqr, tau, thue]

   > # Вычисление значения функции 7  0Эйлера и ей обратной
   > phi(40); phi(1294700); phi(250);
                          16  466400  100

   > invphi(100);
                         [121,125,202,250]

   > # Предикат для определения того факта, что число свободно
   > # от квадратов
   > ifactor(77); issqrfree(77);
                            7*11  true

   > # Вычисление значения функции 7 p 0(x)
   > pi(100)
                                25

   > # Вычисление чисел Мерсенна
   > mersenne(11);
                                31

   > mersenne(86243);

   5369279955027563215223382779929453006110209940421240059156786394
   433534629821034798964395551413140596 2[ 0... 325762 digits 0... 2] 084693761
   0590569770541508960017803294591435320137691545632232025096086790
   6195719699857021709433438207

   > # Вычисление количества цифр в десятичной записи числа Мерсенна
   > length(mersenne(86243));
                               25962

   > # Вычисление чисел Ферма
   > fermat(9,'q');
   1340780792994259709957402499820584612747936582059239337772356144
   3721764030073546976801874298166903427690031858186486050853753882
   811946569946433649006084097

   > q;

   it is completely factored , (2 516 0*37+1)*(364043106721088096110224
   4011816628378312190597*2 511 0+1)*(362128936829849024182024971631805
   407255830459520272960891514314523640507570656742232821636569307*
   2 511 0+1)

   > q:=fermat(3);
                               q:=257

   > # Вычисление безопасного простого числа, ближайшего сверху
   > # к заданному натуральному числу
   > safeprime(100);
                                 107

   > a:=safeprime(323304894015216546587068731061060010043806210137);
        a:=323304894015216546587068731061060010043806227043
   > isprime((a-1)/2);
                               true

   > # Вычисление первообразного (примитивного) корня по модулю
   > # nextprime(2^10), большего 3
   > primroot(3,nextprime(2^10));

 ш1.2
                  3Работа с примерами решённых задач
 ш1.1
   См. Пример 4, Пример 5, Пример 6.

 ш1.2
                       3Биографические сведения
 ш1.1
    _ 1Эйлер Леонард . 0 (15.04.1707-18.09.1783) - математик,  физик, меха-
ник и астроном.
   Л.Эйлер жил в 1766-1783 на Васильевском острове (наб. Лейтенанта
Шмидта, 15).

    _ 1Эдлман 0  1Леонард . 0 ( 1Adelman 0  1Leonard 0) (31.12.1930)  -  криптограф  из
Университета Южной Калифорнии,  являющийся основателем научной дис-
циплины,  занимающейся конструированием и  анализом  вычислительных
устройств на базе цепочек ДНК.
   Л.Эдлман окончил Калифорнийский университет (Беркли),  где полу-
чил степень  бакалавра  (1968)  и  защитил  докторскую  диссертацию
(1976). Профессор информатики и молекулярной биологии в Университе-
те Южной Калифорнии (США).
   Л.Эдлман является  одним из изобретателей криптосистемы с откры-
тым ключом, основой которой является  _ 1алгоритм RSA . 0, названный так по
начальным буквам фамилий его авторов и использующийся, в частности,
для шифрования цифровых подписей.
   Л.Эдлман является  первым исследователем,  кто смог использовать
для вычислений молекулы ДНК. В 1994 ученый, переключившийся с крип-
тографии на изучение биомолекулярных кодов,  продемонстрировал, что
с помощью единственной пробирки с ДНК можно весьма эффектно  решать
классическую комбинаторную задачу о коммивояжере,  т.е.  отыскивать
кратчайший маршрут обхода вершин графа.
   При работе  на обычном,  "классическом компьютере" данная задача
требует параллельных вычислений, а метод ДНК, предложенный Л.Эдлма-
ном,  позволяет сгенерировать все возможные варианты решений однов-
ременно и с помощью известных биохимических реакций быстро  отфиль-
тровать нить ДНК,  в которой закодирован ответ. Результаты исследо-
ваний изложены в статье "Молекулярные подходы к решению комбинатор-
ных задач".
   При масштабировании задачи в сторону увеличения всего в 25  раз,
вес ДНК, необходимой для представления всех возможных вариантов ис-
ходных данных,  превысит вес Земли. Именно это обстоятельство стало
причиной того,  что компания IBM сразу предпочла сфокусироваться на
других  идеях  альтернативных  компьютеров,  таких,  как  1углеродные
 1квантовые компьютеры 0 и  1нанотрубки 0.
   Л.Эдлман (вместе с Р.Ривестом и А.Шамиром) за вклад в  изобрете-
ние криптосистемы RSA был удостоен премии ACM Turing Award, которую
часто называют "Нобелевской премией по информатике" (2002).
 ш1.2

             2ПРИМЕРЫ РЕШЕНИЯ НЕКОТОРЫХ ТИПОВ УПРАЖНЕНИЙ

 ш1.0
                                        1Передается мысль, выведенная
                                        1из опыта, но не сам опыт.
                                                        1К.Д.Ушинский
 ш1.2

    2Пример 1. 0 [Утешев,Черкасов,Шапошников,2001,с.82-83]
   Резидент разведки  хочет  секретно  переслать  Центру сообщение,
состоящее из одного слова "ряд".
   Зашифруйте его с помощью ключей алгоритма RSA.
    _ 1Решение . 0.
   1.  _ 1Работа Центра . 0.  Случайным образом выбираются простые числа p 41
и p 42 0. Например:
 ш1.0

   p 41 0= 23, p 42 0= 43 => m=989, 7 f 0(m)= (23-1)(43-1)= 924.

 ш1.2
   Далее случайным образом выбирается ключ дешифрования  3d 0 из единс-
твенного ограничения ( 3d 0, 7f 0(m))=1. Такому условию  удовлетворяет, на-
пример,  3d 0=47. В качестве  ключа шифрования  3e 0 берётся обратное  3d 0 от-
носительно умножения по модулю  7f 0(m):  3e 0=59.
   Ключ шифрования ( 3e 0,m) открыто посылается резиденту.
   2.  _ 1Работа резидента . 0. Получив ключ шифрования (и удостоверившись,
что этот  ключ принадлежит действительно Центру),  резидент сначала
кодирует сообщение: x=173205.
   Далее он обращает внимание на то,  что x>m,  и если он формально
зашифрует открытый текст по схеме алгоритма  RSA,  то  восстановить
открытый текст  x Центр не сможет.  Поэтому резидент разбивает x на
блоки x 4j 0, по величине меньшие модуля m, которые и будет шифровать.
   Например:
 ш1.0

   x= 173│205, x 41 0= 173, x 42 0= 205.

 ш1.2
   Способы разбиения  закодированного сообщения на блоки оговарива-
ются заранее между Центром и резидентом.
   Теперь резидент шифрует блоки x 4j 0: c 41 0=818, c 42 0=421 и полностью за-
шифрованное сообщение выглядит теперь как  c=818421.  Эта  шифровка
открыто посылается Центру.
   3.  _ 1Работа Центра . 0.  Получив шифровку и убедившись, что она пришла
действительно от резидента,  Центр разбивает её на блоки, дешифрует
известным ему ключом дешифрования ( 3d 0,m):
 ш1.0

   818 547 7= 0 173 (mod 989), 421 547 7= 0 205 (mod 989),

 ш1.2
и декодирует текст.

    2Пример 2. 0 (По [Нечаев,1999,с.30])
   Приведите пример реализации протокола криптографической  системы
с открытым ключом.
    _ 1Решение . 0. Пусть у  _ 1абонента . A 0 имеются: p 41 0=7, p 42 0=23 - простые числа
абонента A, r=p 41 77 0p 42 0= 3161 0,  7f 0(161)= 7f 0(7) 7f 0(23)=6 77 022=132, а= 37 0 - случайное
число, причём a< 7f 0(161) и (a, 7f 0(161))=1.
   Пусть у  _ 1абонента . B 0 имеются: q 41 0=11, q 42 0=17 - простые числа абонен-
та  В,  s=q 41 77 0q 42 0= 3187 0,   7f 0(187)= 7f 0(11) 7f 0(17)=10 77 016=160,  b= 39 0 - случайное
число, причём a< 7f 0(187) и (a, 7f 0(187))=1.
   Тогда  _ 1телефонная книга . 0, открытая для всех абонентов, имеет вид:
 ш1.0

  ┌───────────┐
  │ А: 161, 7 │
  │ В: 187, 9 │
  └───────────┘

 ш1.2
   В этой  книге  первое  число является произведением двух простых
чисел, известных только одному абоненту; второе число является отк-
рытым ключом,  доступным каждому желающему передать секретное сооб-
щение этому абоненту.
   Каждый из абонентов находит свой закрытый ключ (для A -  7a 0, для B
-  7b 0), решая соответствующие сравнения:
 ш1.0

   7 77a= 0 1 1  0(mod 132) =>  7a= 0 19 (mod 132) =>  7a 0= 19 (0< 7a 0<132);

   9 77b= 0 1 1  0(mod 160) =>  7b= 0 89 (mod 132) =>  7b 0= 89 (0< 7b 0<160).

 ш1.2
   Пусть А решает послать В секретное сообщение
 ш1.0

   m=  33 0, m<187.

 ш1.2
   Тогда он шифрует сообщение  с помощью   1открытых ключей 0 (187 и 9)
абонента В:
 ш1.0

   m 41 7= 0  33 59 7= 0 48 (mod 187) 1,  00<m 41 0<187.

 ш1.2
   Абонент В расшифровывает это сообщение своим  1закрытым ключом 0 89:
 ш1.0

   m 42 7= 0 48 589 0 (mod 187)=  33 0.
 ш1.2

    2Пример 3. 0 (По [Нечаев,1999,с.28])
   Приведите пример реализации протокола криптографической  системы
без передачи ключей.
    _ 1Решение . 0. Предположим, что абоненты A и В решили установить между
собой скрытую связь без передачи ключей.
   Для этого они совместно выбрали простое число р=23.
   Далее абонент А выбирает случайным образом число а=5,  абонент В
случайно выбирает число b=7.
   Абонент А решает сравнение
 ш1.0

                              7f 0( 7f 0(23))-1
   5 77a= 0 1 (mod  7f 0(23)) =>  7a= 0 5           7= 0 9 (mod 22), 0< 7a 0<22.

 ш1.2
   Теперь  _ 1закрытыми ключами абонента . А 0 являются числа 5 и 9.
   Абонент В решает сравнение
 ш1.0

                              7f 0( 7f 0(23))-1
   7 77b= 0 1 (mod  7f 0(23)) =>  7b= 0 7           7= 0 19 (mod 22), 0< 7b 0<22.

 ш1.2
   Теперь  _ 1закрытыми ключами абонента . B 0 являются числа 7 и 19.
   Абонент А решает передать абоненту В секретное сообщение
 ш1.0

   m=  317 0, m<p-1= 22.

 ш1.2
   Тогда он сначала шифрует это  сообщение  своим  первым  закрытым
ключом 5:
 ш1.0

   m 41 7= 0 17 55 7= 0 21 (mod 23).

 ш1.2
   Второй абонент,  получив это сообщение, шифрует его своим первым
закрытым ключом 7 и отправляет его обратно абоненту А:
 ш1.0

   m 42 7= 0 21 57 7= 0 10 (mod 23).

 ш1.2
   Абонент А шифрует полученное  сообщение  своим  вторым  закрытым
ключом 9 и отправляет шифрованное сообщение абоненту В:
 ш1.0

   m 43 7= 0 10 59 7= 0 20 (mod 23).

 ш1.2
   Получив это  сообщение,  абонент В расшифровывает его при помощи
своего второго закрытого ключа 19:
 ш1.0

   m 44 7= 0 20 519 7= 0 17 (mod 23),

 ш1.2
а так как 0<17<23, то m=17.
                     3Использование пакета Maple
    2Пример 4. 0 Демонстрация реализации  1RSA 0 с помощью  математического
пакета Maple.
 ш1.0

   > # Пара (E,m) - ключ шифрования;
   > # пара (D,m) - ключ дешифрования
   > # ------------------------------
   > with(numtheory):
   > # -----------------------------------------
   > # Выбор первого  о т к р ы т о г о  ключа m
   > # -----------------------------------------
   > p1:=23; p2:=43; M:=p1*p2;
   > ifactor(M);
   > # ---------------------------------
   > # Выбор  з а к р ы т о г о  ключа D
   > # --------------------------------------------
   > D1:=47; igcd(D1,phi(M));  # Проверка выбора D1
   > # --------------------------------------------
   > # Выбор второго  о т к р ы т о г о  ключа E
   > # -----------------------------------------
   > E:=D1 &^ (phi(phi(M))-1) mod (phi(M));
   > # ------------------------------------
   > m:=205;  # Кодируемый текст, m<M
   > # --------------------------------
   > # Процесс передачи и приёма текста
   > # -----------------------------------------
   > m1:=m  &^ E  mod M;   # Зашифрованный текст
   > m2:=m1 &^ D1 mod M;   # Расшифрованный текст
   > m-m2;                 # Проверка результатов передачи текста
 ш1.2

    2Пример 5. 0 Демонстрация реализации RSA с помощью  математического
пакета Maple.
 ш1.0

   > with(numtheory);
   > # Абонент A выбирает два случайных простых числа p1 и p2 и
   > # случайное целое число 0<a<phA, (a,phA)=1.
   > # Ключи rA и a являются открытыми ключами
   > # --------------------------------------─
   > p1:=nextprime(2342323412312311231231238);
     p2:=nextprime(2121212121211235338763453);
     rA:=p1*p2; phA:=phi(rA); a:=29; igcd(a,phA);

                   p1:=2342323412312311231231273
                   p2:=2121212121211235338763473
       rA:=4968564813993736700705615148918684300967107691129
      phA:=4968564813993736700705610685383150777420537696384
                               a:=29
                                 1

   > # Вычисление секретного ключа alpha для A
   > alpha:=a&^(phi(phA)-1) mod phA;

      alpha:=856649105860989086328553566445370823693196154549

   > # Абонент B выбирает два случайных простых числа q1 и q2 и
   > # случайное целое число 0<b<phB, (b,phB)=1.
   > # Ключи rB и b являются открытыми ключами
   > # ---------------------------------------
   > q1:=nextprime(131111231);
     q2:=nextprime(12171212311231);
     rB:=q1*q2; phB:=phi(rB); b:=37; igcd(b,phB);

                           q1:=131111243
                        q2:=12171212311261
                    rB:=1595782774946332607423
                    phB:=1595782762774989184920
                               b:=37
                                 1

   > # Вычисление секретного ключа betta для B
   > betta:=b&^(phi(phB)-1) mod phB;

                   betta:=129387791576350474453

   > # Кодируемый текст (важно, чтобы m<rB)
   > m:=1234567891011121314151;

                     m:=1234567891011121314151

   > # Абонент A шифрует исходный текст (m1 - шифр) с помощью
   > # открытых ключей b и rB абонента B
   > m1:=m&^b mod rB;
                     m1:=158556914698572352618

   > # Абонент B расшифровывает закодированный текст m1 с помощью
   > # своего секретного ключа betta и открытого ключа rB
   > m2:=m1&^betta mod rB;

                    m2:=1234567891011121314151
 ш1.2

    2Пример 6. 0  Демонстрация реализации  _ 1системы . RSA  _без передачи клю-
 _ 1чей . 0 с помощью математического пакета Maple.
 ш1.0

   > with(numtheory);
   > # Абоненты A и B выбирают совместно случайное простое число p
   > p:=nextprime(1235666991231238234523);

                     p:=1235666991231238234541

   > # Абонент A выбирает случайное целое число a, (a,p-1)=1.
   > # Ключ a является первым секретным ключом абонента A
   > # ---------------------------------------------─----
   > a:=nextprime(1238); igcd(a,p-1);
                              a:=1249
                                 1

   > # Вычисление второго секретного ключа alpha для A
   > alpha:=a&^(phi(phi(p))-1) mod phi(p);

                   alpha:=433324373226006682729

   > # Абонент B выбирает случайное целое число b, (b,p-1)=1.
   > # Ключ b является первым секретным ключом абонента B
   > # ---------------------------------------------─----
   > b:=nextprime(123834); igcd(b,p-1);

                             b:=123853
                                 1

   > # Вычисление второго секретного ключа betta для B
   > betta:=b&^(phi(phi(p))-1) mod phi(p);

                   betta:=1102206216428041914197

   > # Кодируемый текст (важно, чтобы m<p-1)
   > m:=123456789101112131415;

                     m:=123456789101112131415

   > # Абонент A шифрует исходный текст m с помощью своего
   > # первого секретного ключа a
   > m1:=m&^a mod p;
                     m1:=873764524847617431428

   > # Абонент B шифрует m1 с помощью своего первого
   > # секретного ключа b
   > m2:=m1&^b mod p;
                     m2:=295341732700159888505

   > # Абонент A шифрует m2 с помощью своего второго
   > # секретного ключа alpha
   > m3:=m2&^alpha mod p;
                     m3:=563426892693809468907

   > # Абонент B расшифровывает m4 (получая в результате m)
   > # с помощью своего второго секретного ключа betta
   > m4:=m3&^betta mod p;
                     m4:=123456789101112131415
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 1.
 ш1.0

   ; Демонстрация простейшей криптосистемы без передачи ключей:
   ;   p    - простое число, известное обоим абонентам;
   ;   Text - натуральное число (Text<p-1), которое является
   ;          передаваемым сообщением
   ; --------------------------------
   (DEFUN Crypto (LAMBDA (p Text)
      (SETQ a 5) ; a - первый секретный ключ первого абонента, 
                 ; (a,p-1)=1 
      (SETQ b 7) ; b - первый секретный ключ второго абонента, 
                 ; (b,p-1)=1
      ; ---------------------------------------------------
      ; Вычисление Alpha - второго секретного ключа первого 
      ; абонента, который является решением сравнения
      ;
      ;   a*Alpha=1 (mod Fi(p)), 0<Alpha<p-1, Fi - функция Эйлера
      ;
      ; ------------------------------------------------------------
      (SETQ Alpha (Modul a (Euler p 1) (- (Euler (Euler p 1) 1) 1)))
      ; ---------------------------------------------------
      ; Вычисление Betta - второго секретного ключа второго
      ; абонента, который является решением сравнения
      ;
      ;   b*Betta=1 (mod Fi(p)), 0<Betta<p-1, Fi - функция Эйлера
      ; 
      ; ------------------------------------------------------------
      (SETQ Betta (Modul b (Euler p 1) (- (Euler (Euler p 1) 1) 1)))
      ; ------------------------------------------------------------
      ; Функционирование криптосистемы
      ; ------------------------------
      (SETQ m1 (Modul Text p a))
      (SETQ m2 (Modul m1 p b))
      (SETQ m3 (Modul m2 p Alpha))
      (RETURN (Modul m3 p Betta))
   ))

   ; ----------------------------------------------------
   ; Функция ("быстрая"), вычисляющая m-ю степень числа n
   ; с помощью алгоритма квадратов и умножений (или алго-
   ; ритма индийского потенцирования)
   ; --------------------------------
   (DEFUN StepQuick (LAMBDA (n m)
      (COND ( (ZEROP m) 1 )
            ( (ZEROP (REM m 2)) (StepQuick (* n n) (/ m 2)) )
            (  T  (* n (StepQuick (* n n) (/ (- m 1) 2))) ))
   ))

   ; -------------------------------------------------
   ; Функция, вычисляющая результат операции двоичного
   ; потенцирования по модулю a:
   ;   m
   ;  n (mod a)
   ; ----------------------
   (DEFUN Modul (LAMBDA (n a m)
      (COND ( (ZEROP m) 1 )
            ( (ZEROP (REM m 2)) 
                  (Modul (REM (* n n) a) a (/ m 2)) )
            (  T  (REM (* n (Modul (REM (* n n) A) 
                                   a 
                                   (/ (- M 1) 2))) a) ))
   ))

   ; ----------------------------------------------------
   ; Функция, вычисляющая наибольший общий делитель (НОД)
   ; двух положительных натуральных чисел
   ; ------------------------------------
   (DEFUN NOD (LAMBDA (a b)
      (COND ( (= a b) a )
            ( (> a b) (NOD (- a b) b) )
            (   T     (NOD a (- b a)) ))
   ))

   ; ---------------------------------------------------------
   ; Функция, возвращающая значение функции Эйлера (количество
   ; чисел из 0,1,2,...,n-1 взаимно простых с n);
   ;  k - накапливающий параметр (при запуске k=1)
   ; ---------------------------------------------
   (DEFUN Euler (LAMBDA (n k)
      (COND ( (= n 1) 1)
            ( (= k n) 0)
            ( (= (NOD k n) 1) (+ 1 (Euler n (+ k 1))) )
            (  T  (Euler n (+ k 1)) ))
   ))

   ; ---------------------------
   ; Неудачные тестовые примеры:
   ; ---------------------------
   (EQUAL (Crypto 97 1)   1)
   (EQUAL (Crypto 97 30) 30)
   (EQUAL (Crypto 97 40) 40)
   (EQUAL (Crypto 97 95) 95)
   ; ---------------------------------------------------
   (EQUAL (Modul 123 511 2) (REM (StepQuick 123 2) 511))
   (EQUAL (Modul 123 511 4) (REM (StepQuick 123 4) 511))
   (EQUAL (Modul 123 511 5) (REM (StepQuick 123 5) 511))
   ; ---------------------------------------------------
   (RDS)
 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                      1Береги себя прилежно и в следующем 0: 1 не  выходи
                      1безвременно из  келии твоей, кроме необходимой
                      1нужды, например, чтобы  послушать, любви ради,
                      1ближнего,  или чтобы немощному послужить,  или
                      1если от Настоятеля куда послан будешь и скорее
                      1в келию свою возвращайся с покойным духом. 0
                             1Игумен Назарий 0 ( 1Кондратьев 0) ( 11735-1809 0)
 ш1.2
 
                           21. 3 Алгоритм RSA
    21. 0 (По [Рябко,Фионов,2018,с.38-39,№2.17])
   В системе RSA с заданными параметрами p 41 0, p 42 0,  3a 0 найдите недоста-
ющие параметры и опишите процесс передачи сообщения m абоненту A:
 ш1.1
   (а) p 41 0=5, p 42 0=11,  3a 0=3, m=12;  (г) p 41 0=7, p 42 0=13,  3a 0=5, m=30;
   (б) p 41 0=5, p 42 0=13,  3a 0=5, m=20;  (д) p 41 0=3, p 42 0=11,  3a 0=3, m=15.
   (в) p 41 0=7, p 42 0=11,  3a 0=7, m=17;

 ш1.2
    22. 0 (По [Утешев,Черкасов,Шапошников,2001,с.81])
   Покажите, что в алгоритме RSA при  (p 41 0-1,3)=1, (p 42 0-1,3)=1  ключу
шифрования  3e 0=3 соответствует ключ дешифрования
 ш1.0

             7f 0(m)-1   1+2 77f 0(m)
    3d 0= 1  7f 0(m)- 1 ────── 0 = ────────.
              3         3

 ш1.1
    _ 1Указание . 0. Вначале воспользуйтесь обобщённым  алгоритмом  Евклида
для решения требуемого сравнения:
 ш1.0

   m  ═+ 0 p 41 77 0p 42 0 =>  3e 77 3d 7= 01 1  0(mod  7f 0(m)) =>  7a7 03 +  7b7f 0(m)= 1 =>

                   1- 7b7f 0(m)
             =>  3d 7= 1  0──────── ( 1mod 0  7f 0(m)),  7bе ═Z 0.
                      3

 ш1.2
    23. 0 (По [Утешев,Черкасов,Шапошников,2001,с.111])
   Докажите, что  если  можно  взять  3e 0=3 или  3e 0=2 516 0+1, то  процедура
шифрования x 5e 0  1mod 0 m становится особенно лёгкой.
    24. 0 (По [Деза,Котова,2018,с.136,№10])
   Найдите такой модуль для системы RSA,  чтобы в  качестве  ключей
можно было использовать числа 3, 5, 7, 9, 11, 13, 15.
    25. 0 [Осипян,Осипян,2004,с.107,№6.33]
   Почему число  2047  будет неудачным выбором для модуля в системе
RSA (кроме того, что это число слишком мало)?
   Приведите примеры подобных "неудачных" модулей.
    26 4* 2. 0 (По [Осипян,Осипян,2004,с.107,№6.34])
   Докажите, что если в системе RSA модуль равен 35,  то закрытые и
открытые ключи будут совпадать.
   Можно ли привести пример ещё одного такого модуля?
    27. 0 (По [Деза,Котова,2018,с.137,№15])
   Найдите все  пары  совпадающих  ключей при использовании системы
RSA по модулю 91, 109, 137, 143, 187, 209.
    28. 0 (По [Деза,Котова,2018,с.137,№17])
   Докажите, что в системе RSA всегда найдутся "неподвижные"  сооб-
щения, т.е. сообщения, переводимые ключами шифрования в себя.
    29. 0 (По [Деза,Котова,2018,с.137,№18])
   Докажите, что  в системе RSA всегда найдутся ключи,  переводящие
все сообщения в себя.
   Приведите соответствующие примеры, используя  модуль r, т.е. со-
общения, переводимые ключами шифрования в себя.
 ш1.0

   (а) 33; (б) 55; (в) 77; (г) 65; (д) 91; (е) 221.

 ш1.2
                  22. 3 Элементарный криптоанализ RSA
    21. 0 (По [Рябко,Фионов,2018,с.39,№2.18])
   Пользователю RSA с параметрами r 4A 0=187, 3 a 0=3 передано  зашифрован-
ное сообщение m=100.
   Расшифруйте это сообщение, взломав систему RSA пользователя.
                    23. 3 Задачи на программирование
    21 4* 2. 0 Реализуйте с помощью математического пакета Maple протокол:
 ш1.1
   (1) криптографической системы с открытым ключом;
   (2) криптографической системы без передачи ключей.

 ш1.2
    22. 0 (По [Рябко,Фионов,2018,с.39,№2.19])
   Напишите и отладьте набор подпрограмм, реализующих  _ 1базовые алго-
 _ 1ритмы . 0, используемые в криптосистеме RSA:
 ш1.1
   (1) возведение в степень (a 5x 1 mod 0 m);
   (2) вычисление наибольшего общего делителя ( 1gcd 0(a,b));
   (3) вычисление "обратного" числа, т.е.  1мультипликативно обратно-
 1го к числу a по модулю m 0 (a 5-1 1 mod 0 m).

 ш1.2
    23. 0 (По [Рябко,Фионов,2018,с.39,№2.23])
   Напишите программу на любом языке программирования,  реализующую
алгоритм RSA для передачи секретных сообщений в адрес  абонентов  A
или B. Рекомендуемые значения параметров таковы:
 ш1.0

   p 41 0=131, p 42 0=227, q 41 0=113, q 42 0=281, 3 a 0=3,  3b 0=3.

 ш1.2
    24. 0 Реализуйте с  помощью  математического пакета Maple  протокол
Рабина.
    25. 0 (По [Ян,2011,с.77])
   Реализуйте "симметричную"  _ 1криптосистему Полига-Хеллмана . 0 (S.C.Poh-
lig, M.Hellman,1978), протокол которой приведём ниже.
   Обозначим M и C соответственно открытый и закрытый тексты.
   Выберем простое p, состоящее из не менее чем 200 десятичных раз-
рядов и закрытый ключ шифрования 3 e 0,  3e 7е ═N 0, 7  01 7, 3e 7, 0p-2.
   Вычислим 3 d 7= 51 0/ 4e  0(mod (p-1)).
   Для пары ( 3e 0,p) и значения 3 d 0 необходимо обеспечить конфиденциаль-
ность. Теперь шифрование легко выполняется авторизованным пользова-
телем: C 7= 0M 5e 0 (mod p). Дешифрование выполняется так: C 7= 0M 5e 0 (mod p).
   Безопасность криптосистемы основана на вычислительной неразреши-
мости задачи о дискретном логарифме. Например, если криптоаналитику
неизвестны 3 e 0 или  3d 0, то необходимо будет вычислить
 ш1.0

    3e 7= 0 log 4M 0(C) (mod p).

 ш1.2
    3Замечание 0.
 ш1.1
   Схема Полига-Хеллмана не является  1симметричным 0 криптоалгоритмом,
т.к.  для  шифрования  и дешифрования используются различные ключи;
это и не схема с открытым ключом,  потому что ключи легко получаютс
один из другого,  а ключ шифрования и ключ дешифрования должны хра-
ниться в секрете.
 ш1.2

    _ 1Домашнее задание . 0:
 ш1.0

   №№  21 41,2 0;  22 41 0;  23 41,2,4 0  ( 16 задач 0).

 ш1.2
.
                   3О разложении натуральных чисел
                            3на множители
   В теории чисел,  несмотря на многолетнюю её историю и на  интен-
сивные поиски в течение последних 30 лет (2012 г.), эффективный ал-
горитм разложения натуральных чисел на множители так и не найден.
   Конечно, можно,  перебирая все простые числа до m 51/2 0 и  деля  на
них m, найти требуемое разложение.
   Докажем, что количество простых в этом промежутке асимптотически
равно 2 77 0m 51/2 0/ 1log 0(m), где m - натуральное число.
   Пусть 7 p 0(x) -  функция,  значением  которой  является  количество
простых чисел p в интервале 1<p 7, 0x.
   Воспользуемся результатом Ж.Адамара  и ла Валле-Пуссена  (1896),
который  называется   _ 1асимптотическим  законом распределения простых
 _ 1чисел . 0 и утверждает, что
 ш1.0

           x              7p 0(x)
    7p 0(x) 7` 0 ───── или 1 lim 0  ─────── =1.
          1ln 0(x)     x─ 76$ 0 x/ 1ln 0(x)

 ш1.2
   Интересно, что его предположил К.Гаусс в  пятнадцатилетнем  воз-
расте при изучении таблицы простых чисел.
   Дальнейшее очевидно:
 ш1.0

              m 51/2 0     2 77 0m 51/2
    7p 0(m 51/2 0) 7` 0 ────────  7` 0 ───────.
             1ln 0(m 51/2 0)     1ln 0(m)

 ш1.2
   Отсюда находим, что при m, записываемом 100 десятичными цифрами,
найдётся не менее 4 77 010 542 0 простых чисел, на которые придётся  делить
m при разложении его на множители.
   Очень грубые прикидки показывают, что  компьютеру,  выполняющему
миллион делений  в секунду для разложения числа m>10 590 0 таким спосо-
бом на множители потребуется не менее чем 5  010 535 0 лет.
   Известны и более эффективные способы  разложения  на  множители,
чем простой перебор простых делителей, но и они работают очень мед-
ленно.

.
    3Замечание 0 (по [Введение,2012,с.93-94]).
 ш1.1
   Для иллюстрации надёжности RSA в 1977 г.  авторы алгоритма зако-
дировали (a=01, b=02,..., z=26, пробел=00) в виде числа x некоторую
 1английскую 0 фразу и зашифровали её ключом (m состоит из 129 знаков).
 ш1.0

    3e 0= 9007,
   m= 114381625757888867669325779976146612010218296721242362562561
      842935706935245733897830597123563958705058989075147599290026
      879543541

 ш1.1
   Эти два числа и шифртекст
 ш1.0

   c= 9686961375462206147714092225435588290575999112457431987469512
      0930816298225145708356931476622883989628013391990551829945157
      815154

 ш1.1
были опубликованы американским популяризатором науки М.Гарднером.
   Дополнительно сообщалось, что m=p 41 77 0p 42 0, где p 41 0 и p 42 0 - простые чис-
сла, записываемые 64 и 65 десятичными знаками соответственно.
   Эта история завершилась 17 лет спустя  (1994),  когда  D.Atkins,
M.Graff, A.K.Lenstra, P.C.Leyland сообщили о дешифровке фразы и по-
лучении предложения
 ш1.0

   " 1The magic words are squeamish ossifrage 0"
   (рус. " 1Волшебные слова - брезгливый граф 0")

 ш1.1
   При этом соответствующие числа p и q оказались равными
 ш1.0

   3490529510847650949147849619903898133417764638493387843990820577
   32769132993266709549961988190834461413177642967992942539798288533

 ш1.1
   Этот замечательный результат (разложение на множители  129-знач-
ного числа)  был достигнут благодаря использованию алгоритма разло-
жения на множители, называемого  _ 1методом квадратичного решета . 0.
   Выполнение вычислений  потребовало  коллосальных по тем временам
ресурсов. В работе, продолжавшейся  после предварительной  теорети-
ческой подготовки примерно 220 дней, на добровольных началах участ-
вовало около 600 человек и  примерно 1600 компьютеров, объединённых
сетью Интернет.
   Итак, за 17 лет никто так и не смог дешифровать предложенную ав-
торами RSA фразу.  Конечно,  это всего лишь косвенное подтверждение
стойкости системы RSA, но всё же достаточно убедительное.

 ш1.2
.
